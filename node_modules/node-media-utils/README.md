# About node-media-utils Package

This package is a collection of Node JS common utilities for media servers.

# Version history
1.22 YOS-158 LocalTestServer can respond with specified header

1.21 YOS-117 HttpResponseTimeLogger
     LocalTestServer can delay response

1.20 TEC-1571 SystemStatusCollector.collect result includes cpuUtilizationPerCore

1.19 YOS-59 JWT utils can manipulate JWT header part

1.18 YOS-6 getNanoSecTimeStamp and aggregatePromiseForAllOperations
     ConsoleCapture to handle async execution

1.17 YOS-8 JWT utils, SecuredPropertySet

1.16 YOS-1 added HttpRequest and LocalTestServer

1.15 BaseConfig can read multiple and nested config files

1.14.1 TEC-1448 Fix express logging bug

1.14 DEVOPS-1681 Add SystemStatusCollector

1.13 TEC-1234 Update to node version 10.  Add help-log-level

1.12 TEC-1152 Add auth-validator.js

1.11 TEC-853 Logging of different versions share the same config

1.10 Added availableMemory

1.9 Added Logger.enableTemporaryLog

1.8 Added AverageCpuUtilization

1.7 Added util.hexDump

1.6 Added DelayExecutionQueue

1.5 updated modern-syslog version so that it runs on nodejs 6

1.4 Logger bug fix and Mock update
- Logger: was not able to set log level 'silly'
- Mock: prints construction code place with errors and traces

1.3 Compatible with node version 4

1.2 Added CpuUtil

1.1 Versioning schema changed <major>.<minor>
    Mock supports return value.

1.0.1 Added Mock

1.0.0 Initial commit

# Contents

- Config : a base class of application specific command line and config file handling
- DelayExecutionQueue : a utility class that executes given closures at least given interval
- Logger : a wrapper over winston logger
- logger : a precreated instance of Logger
- util : some convenient stuff
- CpuUtil : measures CPU utilization
- AverageCpuUtil : provides moving average of CPU utilization
- availableMemory : a function that provides current available memory size of the system
- ConsoleCapture : unit test tool to capture console outputs
- Mock : generic simple mock
- HttpRequest : sends HTTP request. can use keepAlive
- HttpResponseTimeLogger : automatically logs HTTP response times
- LocalTestServer : acts as an HTTP server for unit tests
- JwtUtils : utility functions for JWT
- SecuredPropertySet : developer helper to detect unexpected property access
- getNanoSecTimeStamp : obtains nano-sec resolution timestamp
- aggregatedPromiseForAllOperations : implementation helper to construct and wait nested promises

# Usage Example
## in package.json
```
  ...
  "dependencies": {
    "node-media-utils": "git+ssh://git@github.com/airtimemedia/node-media-utils.git",
    ...
```

## Config
### in your application specific config JS file
Let's say AppConfig.js
```
var Config = require('node-media-utils').Config;
var nodeutil = require('util');

// config keys
var AppConfig.Param_IntervalSec = 'interval-sec';
var AppConfig.Param_DurationSec = 'duration-sec';
... more ...

// your application specific config class constructor
function AppConfig() {
  var defaultLogFileName = '/tmp/bixby_monitor.log';
  Config.call(this, defaultLogFileName, [
     AppConfig.Param_IntervalSec,
     AppConfig.Param_DurationSec
... more ...
  ]);
}
// inherit from the base
nodeutil.inherits(AppConfig, Config);

// override
// describe parameters
AppConfig.prototype.initArgv = function(argvConfig, defaultConfig) {
 this.argvConfig[AppConfig.Param_IntervalSec] = {
    describe: 'Interval in seconds'
    alias: 'I'
  };
  this.argvConfig[AppConfig.Param_DurationSec] = {
    describe: 'Duration in seconds',
    alias: 'D'
  };
... more ...
  // if you have default values - if not, jus skip this
  defaultConfig[AppConfig.Param_IntervalSec] = AppConfig.DefaultIntervalSec;
  defaultConfig[AppConfig.Param_DurationSec] = AppConfig.DefaultDurationSec;
... more ...
}

// override - optional
AppConfig.prototype.validateConfigParam = function(key) {
  // interval needs to be a proper number
  if (AppConfig.Param_IntervalSec === key) {
    var val = this.getSingle(key);
    if (!val) return;  // if the parameter is optional, need to bail out here
    var sec = parseInt(val);
    if (isNaN(sec) || sec <= 0 || 0x7fffffff < sec) {
      throw new Error("Incorrect interval: " + key + '=' + val);
    }
  }
... more ...
}

// Exports
module.exports.Config = Config;  // for constants
module.exports.AppConfig = AppConfig;
```

In main JS
```
var Logger = require('node-media-utils').Logger;
var logger = require('node-media-utils').logger;
function main() {
  try {
    config = new Config();
  } catch (ex) {
    Logger.enableTemporaryLog();
    logger.error('Config error: ' + ex);
    process.exit(1)
  }
  if (!config.shouldRun) {
    process.exit(0);
  }
  config.setLogLevel(Logger);
  config.logConfig();
```

## DelayExecutionQueue

```
var DEQ = require('node-media-utils').DelayExecutionQueue;

var deq = new DEQ(<delay-ms>, [<queue-max>, <behavior-upon-full>]);
// if <queue-max> is not given or zero, no max.
// <behavior-upon-full> is one of followings:
//  DelayExecutionQueue.kDropOldestUponFull
//  DelayExecutionQueue.kDropLatestUponFull

deq.push(function() { do your stuff 1 });
deq.push(function() { do your stuff 2 });
// if 'do your stuff 1' and 'do your stuff 2' are given within <delay-ms> 'do your stuff 2' is executed after
// <delay-ms> since the execution of 'do your stuff 1'
```

## Auth
```
var auth = require('node-media-utils').auth;
...
auth.validate(jwt, authSecrets, function(err, decoded){
  if (err) {
    handleError(err);
  } else {
    doSomethingWithDecoded(decoded);
  }
});
```

## Logger
In main JS
```
// this is logger class
var Logger = require('node-media-utils').Logger;
...
function main() {
  try {
    config = new Config();
  } catch (ex) {
    Logger.enableTemporaryLog();
    logger.error('Config error: ' + ex);
    process.exit(1)
  }
  if (!config.shouldRun) {
    process.exit(0);
  }
  config.setLogLevel(Logger);
...

```
In any JS
```
// this is logger instance
var logger = require('node-media-utils').logger;
...

// in code
// optionally you can set a tag, which appears on every log entry
logger.tag = 'MyTag';
...

// in code
logger.silly('very verbose log');
logger.verbose('verbose log');
logger.debug('debug log');
logger.info('info log');
logger.warn('warning log');
logger.error('error log');
```

## Util
in any JS
```
var at_util = require('node-media-utils').util;
...
  console.log(at_util.inspect(some_obj));
  console.log(at_util.hexDump(buffer).join('\n'));
```

## CpuUtil
in any JS
```
var CpuUtil = require('node-media-utils').CpuUtil;
...
  var cu = new CpuUtil;
  setInterval(function(){
    console.log('CPU Util%=' + cu.getOverall() * 100);  // or cu.getByCore()
  }, 2000);
```

## AverageCpuUtil
in any JS
```
var AvgCpuUtil = require('node-media-utils').AverageCpuUtil;
...
  var acu = new aCpuUtil([30, 60, 120], 3);
  setInterval(function(){
    var avg = acu.getAverages();
    console.log('Average CPU Util% 30sec=' + avg[30] * 100 + ' 1min=' + avg[60] * 100 + ' 2min=' + avg[120] * 100);
  }, 2000);
```

## availableMemory
in any JS
```
var availableMemory = require('node-media-utils').availableMemory;
...
  availableMemory(function(err, avail) {
    if (err) ....
    console.log('Current available memory size is ' + avail + 'bytes');
  });
```

## SystemStatusCollector
in any JS
```
const SystemStatusCollector = require('node-media-utils').SystemStatusCollector;
...
  const avgCpuUtilAvgWindowSecs = [10, 30, 120];
  const collector = new SystemStatusCollector(avgCpuUtilAvgWindowSecs);
  ...
  const systemStatus = collector.collect();
```

## HttpRequest
in any JS
```
const HttpRequest = require('node-media-utils').HttpRequest;
...
  const httpReq = new HttpRequest('localhost', 8274, 'http', { keepAlive: true });
  const result = await httpReq.send('post', '/over/the/window', { data: 123 }, {
    headers: { authorization: 'auth-token' }
  });
```

## HttpResponseTimeLogger
in main JS
```
Before requiring Node JS https (including Express which requires https)
require('node-media-utils').HttpsResponseTimeLogger;
new HttpsResponseTimeLogger('info');
```

## ConsoleCapture
in unit test JS
```
var ConsoleCapture = require('node-media-utils').ConsoleCapture;

// in a test case
...
  // temporarily redirect the console log - automatically recovers after the execution
  const out = ConsoleCapture.capture(function() {
    Do Your Stuff here
  });
  // 'out' has an array of strings, where each string is one console output
  // right now cout, cerr, stdout, stderr are combined in one array

  // manually starting and stopping capturing
  ConsoleCapture.prologue();
  Do your stuff here
  const out = ConsoleCapture.epilogue();
  // never forget calling epilogue() or you don't see any console output after here.

  // for async function
  const out = await ConsoleCapture.capture(async() => {
    await DoYourStuff
  });
```

## LocalTestServer
```
const testServer = new LocalTestServer();
const [ server, port ] = await testServer.run(results);
/*
results are an Array of Objects that provides server responses.
ex)
const results = [
  {statusCode:200, body:123},
  {statusCode:400, body:'<html><body>Bad request</body></html>'}
];
*/

then send request(s) to the testServer

testServer.requests and testServer.requestBodies stores the sent requests.
These are Arrays.

Also, testServer.connected and testServer.closed are set accordingly.
These flags do not auto reset, so you will want to manually reset if test continues.
```


# API Reference
## Config
### Constants
```
/// Command-line parameters
Config.CommandParam_Config = 'config';         // alias 'c'
Config.CommandParam_Help = 'help';             // alias 'h'

/// Command-line or Config file entries
Config.Param_LogLevel = 'log-level';           // alias 'l'
Config.Param_LogFile = 'log-file';             // alias 'L'
Config.Param_LogFileMaxKB = 'log-file-max-kb';  // alias 'K'
Config.Param_LogMaxFiles = 'log-max-files';     // alias 'N'
Config.Param_UseSysLog = 'syslog';              // alias 'y'
Config.Param_UseConsoleLog = 'console-log';     // alias 'o'

/// Default values
Config.DefaultLogLevel = 'info';
Config.DefaultLogFileMaxKB = 'infinite';
Config.DefaultLogMaxFiles = 'infinite';
Config.DefaultUseSysLog = 'true';
Config.DefaultUseConsoleLog = 'true';
```

### Methods
```
/**
 * ConfigBase is a base class of application specific config handlers.
 * @param defaultLogFileName
 * @param params: application specific config item names in an array.
 */
Config(defaultLogFileName, params)

/// subclass should override
initArgv(this.argvConfig, defaultConfig)


/// @return true if the parameter key is provided by the base config class (this class)
isCommonParam(key)

/// validates that only one config value is given (not none, not twice). otherwise throws
validateConfigParamGivenAndSingle(key)

/// validates that only one config value is given (not twice), if given. otherwise throws
validateConfigParamGivenSingle(key, val)

/// sub class can override. called before validateConfigParam().
/// at this moment, only command line args are accessible (config file has not been read)
/// @return false if no need to run further. Returning false sets the property @a shouldRun to false.
processArgv()

/// subclass can override.
/// called multiple times with each key (only for application specific keys).
validateConfigParam(key)

/// subclass can override. called after all validateConfigParam() calls.
/// when called all given parameters are accessible
postValidateConfigParams() {

/**
 * Retrieves the value of a specific configuration element.
 * If arg and config file entry conflicts, uses arg value.
 *
 * @param key the name of the command-line argument or config file entry to be retrieved
 * @return value associated with the parameter <var>key</var>
 */
get(key)

/// Same as get() but throws if multiply given
getSingle(key)

/// @return a new object that contains all key value pairs (including ones defined by this base class)
getAllItems()

/// @return a new object that contains only application config items as key value pairs
getAllAppItems()

/**
 * helper to set up log level.
 * @param logger: our logger.js module (not its instance or class)
 * Ex)
 * <pre>
   var l = require('node-media-utils').Logger;
   config.setLogLevel(l);
   </pre>
 */
setLogLevel(logger)

/**
 * shows config contents
 */
logConfig()

/// helper. @return true if the value is boolean true or string 'true' or 'yes' (case insensitive)
isTrue(val)

```

## DelayExecutionQueue
### API

```
/**
 * A helper class that executes given closures no earlier than @a delayMs since last closure execution.
 * @param delayMs {number}: the minimum interval between closure executions.
 * @param queueMax {number}: the maximum allowed queued closures. Optional. Default is unlimited. Zero is also for unlimited.
 * @param dropOnMaxPolicy {number}: defines its behavior which closure to be dropped if push() will exceed @a queueMax
 */
DelayExecutionQueue = function(delayMs, queueMax, dropOnMaxPolicy)

/**
 * executes @a closure.
 * If previous closure was executed within @a delayMs, then this delays the execution.
 * @param closure {function()}
 */
DelayExecutionQueue.prototype.push = function(closure)
```

### Constants
```
/// dropping policy used for @a dropOnMaxPolicy given to the constructor
DelayExecutionQueue.kDropOldestUponFull = 1;
DelayExecutionQueue.kDropLatestUponFull = 2;
```

## Logger
### Precreated Instance
logger

### Class Methods
```
/*
 * init[Console|File|SysLog]Logger(option)
 *  for Console:
 *    option = {
 *      timestamp: <func>, (optional. default is in UTC: YY/MM/DD hh:mm:ss.mmm)
 *      level: <see LogLevels above>, (optional, default is 'info')
 *      colorize: <...> (optional)
 *    }
 *  for File:
 *    option = {
 *      filename: <filename>, (required)
 *      timestamp: <func>, (optional)
 *      maxsize: <# of bytes to rotate>, (optional)
 *      maxFiles: <# of log files>, (optional)
 *      level: <see LogLevels above> (optional)
 *    }
 *  for SysLog:
 *    option = {
 *      name: <name>, (required)
 *      level: <see LogLevels above> (optional)
 *    }
 * @note level 'none' disables log output
 */
initConsoleLogger(option)
initFileLogger(option)
initSysLogLogger(option)

/*
 * set[Console|File|SysLog]LogLevel(level)
 * @param level: see initXxxLogger() above
 * @note level 'none' disables log output
 * @return previous level
 */
setConsoleLogLevel(level)
setFileLogLevel(level)
setSysLogLogLevel(level)

/**
 * Sets up logger (maybe temporarily)
 * Enables console logger and syslog logger with info level.
 */
enableTemporaryLog()

/// constructor
/// @param tag: optional. if given, it appears in every log entry
Logger(tag)

### Instance Property
tag  ///< if set / modified, it appears in every log entry

### Instance Method
// writes log
silly(msg)
verbose(msg)
debug(msg)
warn(msg)
error(msg)
```

## Util
### Module Methods
```
// replaces NodeJS's util.inspect with default depth = 10 (original default = 2)
// this is to let third party code inspects deeper.
inspect(obj, opt)

/// @return @a host if it is IP (V4 or V6) address. Otherwise null
isIpAddr(host)

/// @return @a host if it is IPV4 address. Otherwise null
isIpV4Addr(host)

/// @return @a host if it is IPV6 address. Otherwise null
isIpV6Addr(host)

/// @return IP V6 address leading and trailing square bracket removed (if exists)
removeIPv6Bracket(ip)

/// @return true if data is not null and not undefined
isValidData(data)

/// hex-dumps the contents of the @a buffer. @return an array of strings, each entry has a output line.
var hexDump = function(buffer) {
```

## CpuUtil
### Constants
```
CpuUtil.MinIntervalMs = 500;  ///< returns the cached value if getOverall() / getByCore() is called within this interval.
```

### Methods
```
/**
 * constructor
 * @param minIntervalMs (optional): minimum query interval that refetches a new value. default = CpuUtil.MinIntervalMs;
 */
CpuUtil(minIntervalMs)

/// @return overall utilization (between 0 and 1.0) since last call of getOverall or getByCore
getOverall()

/// @return an array of utilization per core (between 0 and 1.0 each) since last call of getOverall or getByCore
getByCore()
```

## AverageCpuUtil
```
/**
 * @param windowSecs {array of number} : moving average windows in sec (can be fraction)
 * @param sampleSec {number} : sampling frequency in sec (can be fraction)
 */
AverageCpuUtil(windowSecs, sampleSec)

/// @return {object} : { <windowSec> : <average utilization> }
getAverages()
```

## availableMemory
availableMemory is a function.
```
/// @param cb : callback. function(err, availableMemoryInBytes)
availableMemory(cb)
```

## SystemStatusCollector
```
/**
 * Constructs the status collector.
 * @param cpuAvgWindowSecs {number} or {array} moving window length(s) of CPU utilization average(s)
 */
SystemStatusCollector(cpuAvgWindowSecs)

/**
 * Collects current system status.
 * @param callback : function(err, resultObj)
 * |resultObj| is an Object contains following items:
 * - numCpus (the number of cores)
 * - cpuUtilization - see CpuUtil.getOverall()
 * - cpuUtilAvg - see AverateCpuUtil.getAverages()
 * - cpuLoadAvg - { min1: <val>, min5: <val>, min15: <val> } see Node JS os.loadavg()
 * - memTotal
 * - memFree - see availableMemory()
 * - cpuUtilizationPerCore - see CpuUtil.getByCore()
 */
collect(callback)
```

## Mock
in unit test JS
```
var Mock = require('node-media-utils').Mock;

// in a test case
  myMock = new Mock(test); // test is like nodeunit's context object or chai's assert, that has ok(<cond>) and equal(a,b)

// you can enable call trace. if enabled it prints calls to the console
  myMock.trace = true;

// mock programming
myMock.expects( <method name> ).thenDo(function( <method args> ) {
  do whatever you want with the args
  if you return a value, that is the called function's return value.
});

// Example
myMock.expects('open').thenDo(function(val, cb) {
  test.equal('abc', val);
  setTimeout(function() {
    cb(null);
  }, 10);
});
```

## HttpRequest
```
/**
 * A class that sends HTTP(s) requests using http.Agent that can use keep-alive connection.
 * @param {String} host
 * @param {Number} port
 * @param {String} protocol. 'http' or 'https'
 * @param {Object} agentOptions. @see http.Agent constructor.
 *        ex. { keepAlive: true, keepAliveMsecs: 5000, maxSockets: 5, timeout: 1000 }
 */
HttpRequest(host, port, protocol, agentOptions)

/**
 * Sends a request
 * @param {String} method, such as 'GET'
 * @param {String} path. such as '/shop/hat'
 * @param {Object or String} reqBody Sent only if method is either POST, PUT or PATCH
 * @param {Object} opts. Current implementation uses Axios. @see https://github.com/axios/axios#request-config
 *                 If the same item is given, it overrides @a httpOptions given in the constructor.
 * @returns Promise for { statusCode: <code>, statusMessage: <msg>, headers: { ... }, body: <resonse body> }
 *          response body is either Object or String based on content-type given by the server.
 */
async send(method, path, reqBody, opts)
```

## HttpResponseTimeLogger
```
/**
 * Constructor sets up response time logging automatically.
 * @param {string} log level. OPTIONAL. error | warn | info | debug | verbose | silly. Default is info. See logging.js
 */
constructor()
```

## LocalTestServer
```
/**
 * Runs the server.
 * @param {Array of Object} results.
 *        An array of responses { statusCode:<code>, body:<body>, headers: {...}, delayMsec:<msec> } for incoming requests.
 *        If body is an object, result content-type is application/json. Otherwise text/html.
 *        delayMsec is optional and defaults to 0ms (immediate response).
 * @returns promise for [ http.Server, port ]
 */
LocalTestServer(results)

```

## JwtUtils
```
const JwtUtils = require('node-media-utils').JwtUtils;
const { signJwtHS256, parseJwt, verifyJwtHS256, signJwtRS256, verifyJwtRS256, generateKey } = JwtUtils;

/**
 * Generates signed JWT token using a secret with HS256
 * @param {Object} obj
 * @param {String} secret
 * @param {Object} headerOpts OPTIONAL. Additional header items. An empty Object adds nothing.
 * @param {Boolean} noIat OPTIONAL. if true, iat is not automatically added. Unless iat is added.
 * @returns {String} JWT
 */
signJwtHS256(obj, secret, headerOpts, noIat)

/**
 * Decodes JWT without verifying it signature
 * @param {String} jwtString
 * @returns {Object} parsed object, or null if failed to parse
 * @throws does not throw
 */
parseJwt(jwtString)

/**
 * Verifies signed JWT signed with HS256 secret
 * @param {String} jwtString
 * @param {String} secret
 * @param (Boolean) ignoreExpiration (optional) default: false
 * @returns {Object} parsed object
 */
verifyJwtHS256(jwtString, secret, ignoreExpiration)

/**
 * Generates signed JWT token using a RS256 privateKey
 * @param {Object} obj
 * @param {String} privateKey
 * @param {Object} headerOpts OPTIONAL. Additional header items. An empty Object adds nothing.
 * @param {Boolean} noIat if true, iat is not automatically added. Unless iat is added.
 * @returns {String} JWT string
 */
signJwtRS256(obj, privateKey, headerOpts, noIat)

/**
 * Verifies RS256 signed JWT
 * @param {String} jwtString
 * @param {String} publicKey
 * @param (Boolean) ignoreExpiration (optional) default: false
 * @returns {Object} parsed object
 * @throws Error if publicKey cannot verify the JWT
 */
verifyJwtRS256(jwtString, publicKey, ignoreExpiration)

/// @returns promise for { public: <public key>, private: <private key> }
generateKey()

/**
 * Parses the header part of JWT
 * @param {String} jwt
 * @returns {Object} parsed JWT header
 * @throws {Error} if JWT is malformed
 */
parseJwtHeader(jwt)
```

## SecuredPropertySet
```
/**
 * @class
 * An object that only allows to get and set its set of properties that are defined at the construction, in debug mode.
 * In debug mode:
 * - setting a property that is not allowed at the constructor throws an error.
 * - getting a property that is not allowed at the constructor, or getting an unset property throws an error.
 * In release mode:
 * - setting and getting a property is as same as regular Object.
 * - has(<name>) of a property that is explicitly set to |undefined| behaves differently from debug mode.
 *   debug mode returns true but release mode returns false.
 * - performance of getters and setters are almost identical to regular Object.
 *
 * Regardless of the mode, in addition to getters and setters of the properties, it also has following properties:
 * - className returns the class name given at the constructor
 * - propertyNames returns an array of defined property names
 * - inDebugMode returns true if this class is configured as debug mode.
 *               In debug mode, it verifies properties validity and availability
 * It has following methods:
 * - has('<prop name>') returns true if the property has already set, false if not.
 *   In release mode, if the property was set with |undefined| it returns false. In debug mode it returns true.
 * - toString() returns string representation of the object
 * - toString() is implicitly called when it is coerced into string
 */
```

## getNanoSecTimeStamp
```
/**
 * @returns current time stamp in nano seconds.
 */
getNanoSecTimeStamp()
```

## aggregatedPromiseForAllOperations
```
/**
 * Let @a processFn aggregate its operational promises into @a aggregator
 * then let @a resultFn decide the result value (or promise)
 * @param {Function} processFn takes (aggregator). See example usage below.
 * @param {Function} resultFn takes (aggregatedPromises :an array of promises) after all promises
 * aggregated in @a processFn have been fulfilled.
 * Then @a resultFn returns a promise or an immediate value that becomes a return value
 * of this function.
 * If not given, undefined is returned.
 * @returns the return value from @a resultFn.
 * @throws if @a processFn or @a resultFn threw, or if any promise added to @a promises is rejected.
 *
 * Example:
 * <pre>
 * someFunction()
 *   return aggregatePromiseForAllOperations(
 *     (aggregator => {
 *        // to add a operational promise
 *        const completer = aggregator.add();
 *        // later maybe async
 *        completer.resolve(someValue);
 *        // or
 *        completer.reject(someError);
 *        // then after adding all operational promises
 *        aggregator.done();
 *        // of if it failed to add all operational promises
 *        aggregator.failedToAggregate(someError);
 *      },
 *      (aggregatedPromises => {
 *   });
 * };
 * </pre>
 */
aggregatePromiseForAllOperations(processFn, resultFn)
```
