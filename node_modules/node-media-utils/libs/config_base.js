/**
 * @file Base class to handle configuration of the application.
 * @copyright Â© 2015 Airtime Media.  All rights reserved.
 */

var nconf = require('nconf');
var path = require('path');
var NConfProvider = nconf.Provider;
var logger = require('./logging').logger;
var util = require('./util');

/// Command-line parameters
Config.CommandParam_Help = 'help';

/// Command-line or Config file entries
Config.Param_Config = 'config';
Config.Param_LogLevel = 'log-level';
Config.Param_LogFile = 'log-file';
Config.Param_LogFileMaxKB = 'log-file-max-kb';
Config.Param_LogMaxFiles = 'log-max-files';
Config.Param_UseSysLog = 'syslog';
Config.Param_UseConsoleLog = 'console-log';
Config.Param_HelpLogLevel = 'help-log-level';
Config.CommonParams = [
  Config.Param_Config,
  Config.Param_LogLevel,
  Config.Param_LogFile,
  Config.Param_LogFileMaxKB,
  Config.Param_LogMaxFiles,
  Config.Param_UseSysLog,
  Config.Param_UseConsoleLog,
  Config.Param_HelpLogLevel
];

/// Default values
Config.DefaultLogLevel = 'info';
Config.DefaultLogFileMaxKB = 'infinite';
Config.DefaultLogMaxFiles = 'infinite';
Config.DefaultUseSysLog = 'true';
Config.DefaultUseConsoleLog = 'true';
Config.DefaultHelpLogLevel = 'log';

/**
 * ConfigBase is a base class of application specific config handlers.
 * @param defaultLogFileName
 * @param params: application specific config item names in an array.
 */
function Config(defaultLogFileName, params) {
  this.params = Config.CommonParams.concat(params);
  this.defaultLogFileName = defaultLogFileName;

  // properties
  this.shouldRun = false;
  this.confFilesRead = [];

  this.argConf_ = new NConfProvider();
  this.fileConf_ = new NConfProvider();
  this.defaultConf_ = new NConfProvider();

  this.initArgv_();
  this.processArgv_();
  if (!this.shouldRun) return;
  this.processConfigFile_();
  this.validate_();
}

/**
 * Tells nconf about the command-line arguments we wish to accept.
 */
Config.prototype.initArgv_ = function() {
  this.argvConfig = {};
  // we cannot use 'default:' above, because we'd lose track of distinction whether is's defaulted.
  // we do it manually here
  var defaultConfig = {};

  // subclass invocation
  this.initArgv(this.argvConfig, defaultConfig);

  this.argvConfig[Config.Param_Config] = {
    describe: 'Path to a configuration file to be loaded. Multiple files can be given. ' + 
              'Also, can be appear in a config file.',
    alias: 'c'
  };
  this.argvConfig[Config.Param_LogLevel] = {
    describe: 'Minimum log level [debug|info|warn|error|none] (default=' + Config.DefaultLogLevel + ')',
    alias: 'l'
  };
  this.argvConfig[Config.Param_LogFile] = {
    describe: 'Log file path/name. "" or "none" disables file log. (default=' + this.defaultLogFileName + ')',
    alias: 'L'
  };
  this.argvConfig[Config.Param_LogFileMaxKB] = {
    describe: 'Suggested max size (means sometimes overrun) log file. (default=infinite)',
    alias: 'K'
  };
  this.argvConfig[Config.Param_LogMaxFiles] = {
    describe: 'Max number of log files. (default=infinite)',
    alias: 'N'
  };
  this.argvConfig[Config.Param_UseSysLog] = {
    describe: 'Enables syslog output [true|false] (default=' + Config.DefaultUseSysLog + ')',
    alias: 'y'
  };
  this.argvConfig[Config.Param_UseConsoleLog] = {
    describe: 'Enables console log output [true|false] (default=' + Config.DefaultUseConsoleLog + ')',
    alias: 'o'
  };
  this.argvConfig[Config.Param_HelpLogLevel] = {
    describe: 'Log level for help menu [log|error] (default=' + Config.DefaultHelpLogLevel + ')',
    alias: 'H'
  };
  this.argvConfig[Config.CommandParam_Help] = {
    describe: '[Command line only] Shows this help',
    alias: 'h'
  };
  this.argConf_.argv(this.argvConfig);

  defaultConfig[Config.Param_LogLevel] = Config.DefaultLogLevel;
  defaultConfig[Config.Param_LogFile] = this.defaultLogFileName;
  defaultConfig[Config.Param_LogFileMaxKB] = Config.DefaultLogFileMaxKB;
  defaultConfig[Config.Param_LogMaxFiles] = Config.DefaultLogMaxFiles;
  defaultConfig[Config.Param_UseSysLog] = Config.DefaultUseSysLog;
  defaultConfig[Config.Param_UseConsoleLog] = Config.DefaultUseConsoleLog;
  defaultConfig[Config.Param_HelpLogLevel] = Config.DefaultHelpLogLevel;
  this.defaultConf_.defaults(defaultConfig);
}

/// subclass should override
Config.prototype.initArgv = function(argvConfig, defaultConfig) {
  throw new Error("Subclass needs to override initArgv()");
}

/**
 * Command line parameter processing
 */
Config.prototype.processArgv_ = function() {
  this.shouldRun = true;
  if (this.argConf_.get(Config.CommandParam_Help)) {
    this.showHelp_();
    this.shouldRun = false;
  }
  if (!this.processArgv()) {  // subclass invocation
    this.shouldRun = false;
  }
}

Config.prototype.showHelp_ = function() {
  var yargs = require('yargs');
  yargs.options(this.argvConfig);
  yargs.help(false);  //  Don't exit

  var helpLogLevel = this.get(Config.Param_HelpLogLevel);
  yargs.showHelp(helpLogLevel);
}

/// sub class can override. called before validateConfigParam().
/// at this moment, only command line args are accessible (config file has not been read)
/// @return false if no need to run further.
Config.prototype.processArgv = function() {
  // if subclass does not override, this is NOOP
  return true;
}

/**
 * If the user has specified configuration files, parse them and add their contents to the current
 * configuration.
 */
Config.prototype.processConfigFile_ = function() {
  let confFile  = this.argConf_.get(Config.Param_Config);
  if (!confFile) return;
  if (typeof confFile === 'string') confFile = [ confFile ];
  let self = this;
  let first = true;
  const commandFileSource = 'command line';
  confFile.forEach(file => {
    if (first) {
      first = false;
      self.processConfigFileImpl_(commandFileSource, file, self.fileConf_);
    } else {
      provider = new NConfProvider();
      self.processConfigFileImpl_(commandFileSource, file, provider);
      self.importSubConfigFileItems_(provider);
    }
  });
}

/**
 * Reads a config file. If the config file has nested config files, read them all.
 * @param {String} parent : where the confFile is specified
 * @param {String} confFile 
 * @param {Object} provider 
 * @returns 
 */
Config.prototype.processConfigFileImpl_ = function(parent, confFile, provider) {
  if (0 <= this.confFilesRead.indexOf(confFile)) {
    // already read and processed
    let msg = `Ignoring duplicate config file ${confFile} provided in ${parent}`;
    console.error(msg);
    logger.warn(msg);
    return;
  }
  logger.info("Reading " + confFile);
  provider.file(confFile);
  this.confFilesRead.push(confFile);

  let nestedConfFiles = provider.get(Config.Param_Config);
  if (!nestedConfFiles) return;
  if (typeof nestedConfFiles === 'string') nestedConfFiles = [ nestedConfFiles ];
  let self = this;
  nestedConfFiles.forEach(filename => {
    let innerProvider = new NConfProvider();
    self.processConfigFileImpl_(confFile, filename, innerProvider);
    self.importSubConfigFileItems_(innerProvider);
  });
};

/**
 * Imports config items in the given sub-provider into the current configuration
 * @param {Object} provider 
 */
Config.prototype.importSubConfigFileItems_ = function(provider) {
  let self = this;
  this.params.forEach(function(key) {
    let val = provider.get(key);
    if (val) {
      let curVal = self.fileConf_.get(key);
      if (curVal === undefined) {
        self.fileConf_.set(key, val);
      } else if (Array.isArray(curVal)) {
        curVal.push(val);
      } else {
        self.fileConf_.remove(key);
        self.fileConf_.set(key, [ curVal, val ]);
      }
    }
  });
}

/**
 * shows config contents
 */
Config.prototype.logConfig = function() {
  var txt = "Configured:\n"
  txt += this.dumpConfig_(this.params);
  logger.info(txt);
}

Config.prototype.dumpConfig_ = function(keys) {
  var self = this;
  var out = '';
  keys.forEach(function(k) {
    out += '  ' + k + ': ' + self.get(k) + "\n";
  });
  return out;
}

/**
 * Verifies that we have legitimate values for all required options.
 */
Config.prototype.validate_ = function() {
  var self = this;
  this.params.forEach(function(key) {
    if (self.isCommonParam(key)) {
      self.validateConfigParamCommon_(key);
    } else {
      self.validateConfigParam(key);  // subclass invocation
    }
  });
  self.postValidateConfigParams();  // subclass invocation
}

Config.prototype.isCommonParam = function(key) {
  return (0 <= Config.CommonParams.indexOf(key));
}

Config.prototype.validateConfigParamCommon_ = function(key) {
  if (Config.Param_Config !== key) {  // Param_Config allows multipe values
    this.validateConfigParamGivenAndSingle(key);
  }
  if (Config.Param_LogLevel === key) {
    var val = this.get(key);
    if (-1 === ['none', 'silly', 'verbose', 'debug', 'info', 'warn', 'error'].indexOf(val)) {
      throw new Error("Incorrect log level: " + key + '=' + val);
    }
  }
  if (Config.Param_HelpLogLevel === key) {
    var val = this.get(key);
    if (-1 === ['log', 'error'].indexOf(val)) {
      throw new Error("Incorrect log level: " + key + '=' + val);
    }
  }
}

Config.prototype.validateConfigParamGivenAndSingle = function(key) {
  var val = this.get(key);
  if (undefined === val) {
    throw new Error("Missing config: " + key);
  }
  this.validateConfigParamGivenSingle(key, val);
}

Config.prototype.validateConfigParamGivenSingle = function(key, val) {
  // fails this test if multiple values to the same key was given
  if (typeof val != 'string' && typeof val != 'number' && typeof val != 'boolean') {
    throw new Error("Duplicate config: " + key + '=' + val + ' ' + typeof val);
  }
}

Config.prototype.validateConfigParam = function(key) {
  // if subclass does not override, this is NOOP
  // 'key' is one in definition, therefore get(key) might be null
}

Config.prototype.postValidateConfigParams = function() {
  // if subclass does not override, this is NOOP
}

/**
 * Retrieves the value of a specific configuration element.
 * If arg and config file entry conflicts, uses arg value.
 *
 * @param key the name of the command-line argument or config file entry to be retrieved
 * @return value associated with the parameter <var>key</var>
 */
Config.prototype.get = function(key) {
  if (!key) throw new Error("get: needs key");
  var val = this.argConf_.get(key);
  if (undefined == val) val = this.fileConf_.get(key);
  if (undefined == val) val = this.defaultConf_.get(key);
  return val;
}

/// Same as get() but throws if multiply given
Config.prototype.getSingle = function(key) {
  var val = this.get(key);
  if (!util.isValidData(val)) return null;
  this.validateConfigParamGivenSingle(key, val);
  return val;
}

/// @return a new object that contains all key value pairs
Config.prototype.getAllItems = function() {
  var result = {};
  var self = this;
  this.params.forEach(function(key) {
    result[key] = self.get(key);
  });
  return result;
}

/// @return a new object that contains only application config items as key value pairs
Config.prototype.getAllAppItems = function() {
  var result = {};
  var self = this;
  this.params.forEach(function(key) {
    if (!self.isCommonParam(key)) {
      result[key] = self.get(key);
    }
  });
  return result;
}

/**
 * helper to set up log level.
 * @param loggerClass: our Logger class (not its instance)
 * Ex)
 * <pre>
   var l = require('node-media-utils').Logger;
   config.setLogLevel(l);
   </pre>
 */
Config.prototype.setLogLevel = function(loggerClass) {
  var level = this.get(Config.Param_LogLevel);
  if (this.isTrue(this.get(Config.Param_UseConsoleLog))) {
    loggerClass.initConsoleLogger({level: level});
  } else {
    loggerClass.initConsoleLogger({level: 'none'});
  }
  if (this.isTrue(this.get(Config.Param_UseSysLog))) {
    loggerClass.initSysLogLogger({name: path.basename(process.argv[1]).split('.')[0],  // main JS file name
                            level: level});
  }
  var logFile = this.get(Config.Param_LogFile);
  if ((typeof logFile == 'boolean') // means empty string was given
   || ('none' == logFile)) {
  } else {
    var option = {filename: logFile, level: level};
    var maxSize = Number(this.get(Config.Param_LogFileMaxKB));
    if (!isNaN(maxSize)) option.maxsize = maxSize * 1024;
    var maxFiles = Number(this.get(Config.Param_LogMaxFiles));
    if (!isNaN(maxFiles)) option.maxFiles = maxFiles;
    loggerClass.initFileLogger(option);
  }
}

Config.prototype.isTrue = function(val) {
  if (typeof val == 'boolean') return val;
  if (typeof val == 'string') {
    var lval = val.toLowerCase();
    return lval == 'true' || lval == 'yes';
  }
  if (typeof val == 'number') {
    return Boolean(val);
  }
  return false;
}

// Exports
module.exports.Config = Config;
