// Copyright Airtime Media, 2022

const util = require('util');

// run modes
FORCE_RELEASE_MODE = 'forcerelease';
FORCE_DEBUG_MODE = 'focedebug';

/**
 * @class
 * An object that only allows to get and set its set of properties that are defined at the construction, in debug mode.
 * In debug mode:
 * - setting a property that is not allowed at the constructor throws an error.
 * - getting a property that is not allowed at the constructor, or getting an unset property throws an error.
 * In release mode:
 * - setting and getting a property is as same as regular Object.
 * - has(<name>) of a property that is explicitly set to |undefined| behaves differently from debug mode.
 *   debug mode returns true but release mode returns false.
 * - performance of getters and setters are almost identical to regular Object.
 *
 * Regardless of the mode, in addition to getters and setters of the properties, it also has following properties:
 * - className returns the class name given at the constructor
 * - propertyNames returns an array of defined property names
 * - inDebugMode returns true if this class is configured as debug mode.
 *               In debug mode, it verifies properties validity and availability
 * It has following methods:
 * - has('<prop name>') returns true if the property has already set, false if not.
 *   In release mode, if the property was set with |undefined| it returns false. In debug mode it returns true.
 * - toString() returns string representation of the object
 * - toString() is implicitly called when it is coerced into string
 */

/**
 * Constructor.
 * @param {Array} propNames An array of String. It is a set of name of allowed properties.
 * @param {Object} initialProps (optional) Properties in it are set at the constructor.
 * @param {String} forcedRunMode (optional) This is for unit test support.
 * It must be either FORCE_RELEASE_MODE or FORCE_DEBUG_MODE. Otherwise it does not override env setting.
 * Usually run mode is contolled by an environmental variable 'CHECK_SECURED_PROPERTIES'. Default is release mode.
 * This argument is to override that setting by the environmental variable.
 * FORCE_RELEASE_MODE to set this as release mode.
 * FORCE_DEBUG_MODE to set this as debug mode.
 */
 module.exports.SecuredPropertySet = function(propNames, initialProps, forcedRunMode) {
  if (!propNames || 0 === propNames.value || !Array.isArray(propNames)) throw new Error('Need propNames');

  if ('object' !== typeof initialProps) {
    forcedRunMode = initialProps;
    initialProps = undefined;
  }

  let debugMode = process.env['CHECK_SECURED_PROPERTIES'];
  if (FORCE_DEBUG_MODE === forcedRunMode) {
    debugMode = true;
  } else if (FORCE_RELEASE_MODE === forcedRunMode) {
    debugMode = false;
  }

  if (debugMode) {
    // debug mode
    this.propNames__ = propNames;

    // To identify a value that is not set. undefined and null can be valid values.
    const NotSet = {};

    for (const propName of propNames) {
      this[makePropName_(propName)] = NotSet;
    }

    const self = this;  // this here is the subclass, and inside function is Proxy
    this.toString = function() {
      const repr = {};
      for (const name of propNames) {
        repr[name] = self[makePropName_(name)];
      }
      return this.className + ':' + util.inspect(repr, { breakLength: Infinity });
    };

    this.has = function(name) {
      return NotSet !== self[makePropName_(name)];
    };

    const proxy = new Proxy(this, this);

    proxy.get = function(target, prop) {
      if ('symbol' === typeof prop) prop = 'toString';  // call to implicit coarcing

      // needs to be after toString check because of Object.toString is a function
      if ('function' === typeof this[prop]) return this[prop];  // subclass's method

      const className = this.constructor.name;
      if ('className' === prop) return className;
      if ('propertyNames' === prop) return this.propNames__;
      if ('inDebugMode' === prop) return true;

      const propName = makePropName_(prop);
      if (!this.hasOwnProperty(propName)) throw new TypeError(`${className} has no property '${prop}' to get`);
      const val = this[propName];
      if (NotSet  === val) throw new ReferenceError(`${className} property '${prop}' has not set`);
      return val;
    };

    proxy.set = function(target, prop, value) {
      const className = this.constructor.name;
      const propName = makePropName_(prop);
      if (!this.hasOwnProperty(propName)) throw new TypeError(`${className} has no property '${prop}' to set`);
      this[propName] = value;
      return true;
    };

    for (const propName in initialProps) {
      proxy[propName] = initialProps[propName];
    }

    return proxy;
  } else {
    // release run
    this.propertyNames = propNames;
    this.className = this.constructor.name;
    this.inDebugMode = false;

    for (const name in initialProps) {
      this[name] = initialProps[name];
    }

    this.has = function(name) {
      return undefined !== this[name];
    };

    this.toString = function() {
      const repr = {};
      for (const name of propNames) {
        repr[name] = this[name];
      }
      return this.className + ':' + util.inspect(repr, { breakLength: Infinity });
    };
  }
}

const makePropName_ = function(propName) { return '_' + propName; }

module.exports.SecuredPropertySet.FORCE_RELEASE_MODE = FORCE_RELEASE_MODE;
module.exports.SecuredPropertySet.FORCE_DEBUG_MODE = FORCE_DEBUG_MODE;
