/// @copyright Â© 2017 Airtime Media.  All rights reserved.

/**
 * A helper class that executes given closures no earlier than @a delayMs since last closure execution.
 * @param delayMs {number}: the minimum interval between closure executions.
 * @param queueMax {number}: the maximum allowed queued closures. Optional. Default is unlimited. Zero is also for unlimited.
 * @param dropOnMaxPolicy {number}: defines its behavior which closure to be dropped if push() will exceed @a queueMax
 *            Either DelayExecutionQueue.kDropOldestUponFull or DelayExecutionQueue.kDropLatestUponFull
 */
DelayExecutionQueue = function(delayMs, queueMax, dropOnMaxPolicy) {
  if (!delayMs || delayMs < 0) {
    throw new Error('delayMs must be given and a positive number');
  }
  if (queueMax && queueMax < 0) {
    throw new Error('queueMax cannot be a negative number');
  }
  if (queueMax && (!dropOnMaxPolicy || dropOnMaxPolicy < 0 || (DelayExecutionQueue.kDropLatestUponFull < dropOnMaxPolicy))) {
    throw new Error('valid dropOnMaxPolicy must be given');
  }
  this.delayMs = delayMs;
  this.queueMax = queueMax || 0;
  this.dropOnMaxPolicy = dropOnMaxPolicy;
  this.queue_ = [];
}
exports.DelayExecutionQueue = DelayExecutionQueue;

/// dropping policy used for @a dropOnMaxPolicy given to the constructor
DelayExecutionQueue.kDropOldestUponFull = 1;
DelayExecutionQueue.kDropLatestUponFull = 2;

/**
 * executes @a closure.
 * If previous closure was executed within @a delayMs, then this delays the execution.
 * @param closure {function()}
 */
DelayExecutionQueue.prototype.push = function(closure) {
  this.dropEntryIfQueueIsFull_();
  var now = Date.now();
  if (!this.timer_) {
    this.executeClosure_(closure);
    return;
  }
  this.queue_.push(closure);
}

DelayExecutionQueue.prototype.dropEntryIfQueueIsFull_ = function() {
  if (0 < this.queueMax && this.queueMax <= this.queue_.length) {
    switch (this.dropOnMaxPolicy) {
      case DelayExecutionQueue.kDropOldestUponFull:
        this.queue_.shift();
        break;
      case DelayExecutionQueue.kDropLatestUponFull:
        this.queue_.pop();
        break;
      default:
        // already checked in the constructor, so cannot happen.
        assert(false);
    }
  }
}

DelayExecutionQueue.prototype.executeClosure_ = function(closure) {
  // call the closure asynchronously
  setTimeout(function() {
    closure();
  }, 0);

  this.scheduleClosureExecution_();
}

DelayExecutionQueue.prototype.scheduleClosureExecution_ = function() {
  if (this.timer_) return;
  var self = this;
  this.timer_ = setInterval(function() {
    self.executeOldestClosure_();
  }, this.delayMs);
}

DelayExecutionQueue.prototype.executeOldestClosure_ = function() {
  if (0 == this.queue_.length) {
    clearInterval(this.timer_);
    this.timer_ = null;
    return;
  }
  this.executeClosure_(this.queue_[0]);
  this.queue_.shift();
}
