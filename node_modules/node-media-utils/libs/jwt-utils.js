// Copyright Airtime Media, 2022

const util = require('util');
const jwt = require('jsonwebtoken');
const generateKeyPair = require('crypto').generateKeyPair;

/**
 * Generates signed JWT token using a secret with HS256
 * @param {Object} obj
 * @param {String} secret
 * @param {Object} headerOpts OPTIONAL. Additional header items. An empty Object adds nothing.
 * @param {Boolean} noIat OPTIONAL. if true, iat is not automatically added. Unless iat is added.
 * @returns {String} JWT
 */
module.exports.signJwtHS256 = function(obj, secret, headerOpts, noIat) {
  return signJwt_('HS256', obj, secret, headerOpts, noIat);
}

const signJwt_ = function(algo, obj, secretOrKey, headerOpts, noIat) {
  if ('boolean' === typeof headerOpts) {
    noIat = headerOpts;
    headerOpts = undefined;
  }
  const opts = { algorithm: algo, noTimestamp: !!noIat };
  if (headerOpts) opts.header = headerOpts;
  return jwt.sign(obj, secretOrKey, opts);
};

/**
 * Decodes JWT without verifying it signature
 * @param {String} jwtString
 * @returns {Object} parsed object, or null if failed to parse
 * @throws does not throw
 */
module.exports.parseJwt = function(jwtString) {
  return jwt.decode(jwtString);
}

/**
 * Verifies signed JWT signed with HS256 secret
 * @param {String} jwtString
 * @param {String} secret
 * @param (Boolean) ignoreExpiration (optional) default: false
 * @returns {Object} parsed object
 */
module.exports.verifyJwtHS256 = function(jwtString, secret, ignoreExpiration) {
  return verify_(jwtString, secret, 'HS256', ignoreExpiration);  // eslint-disable-line no-use-before-define
};

/**
 * Generates signed JWT token using a RS256 privateKey
 * @param {Object} obj
 * @param {String} privateKey
 * @param {Object} headerOpts OPTIONAL. Additional header items. An empty Object adds nothing.
 * @param {Boolean} noIat OPTIONAL. if true, iat is not automatically added. Unless iat is added.
 * @returns {String} JWT string
 */
module.exports.signJwtRS256 = function(obj, privateKey, headerOpts, noIat) {
  return signJwt_('RS256', obj, privateKey, headerOpts, noIat);
};

/**
 * Verifies RS256 signed JWT
 * @param {String} jwtString
 * @param {String} publicKey
 * @param (Boolean) ignoreExpiration (optional) default: false
 * @returns {Object} parsed object
 * @throws Error if publicKey cannot verify the JWT
 */
module.exports.verifyJwtRS256 = function(jwtString, publicKey, ignoreExpiration) {
  return verify_(jwtString, publicKey, 'RS256', ignoreExpiration);  // eslint-disable-line no-use-before-define
}

/**
 * Verifies the token
 * @param {String} jwtString
 * @param {String} secretOrKey
 * @param {String} algo
 * @param (Boolean) ignoreExpiration (optional) default: false
 * @returns
 */
const verify_ = function(jwtString, secretOrKey, algo, ignoreExpiration) {
  let result;
  let options = { algorithm: algo };
  if (ignoreExpiration) options.ignoreExpiration = true;
  jwt.verify(jwtString, secretOrKey, options, (err, decoded) => {
    if (err) throw err;
    result = decoded;
  });
  return result;
};

/// @returns promise for { public: <public key>, private: <private key> }
module.exports.generateKey = function() {
  return new Promise((resolve, reject) => {
    generateKeyPair('rsa', {
      modulusLength: 4096,
      publicKeyEncoding: {
        type: 'spki',
        format: 'pem'
      },
      privateKeyEncoding: {
        type: 'pkcs8',
        format: 'pem'
      }
    }, (err, publicKey, privateKey) => {
      if (err) return reject(err);
      resolve({ public: publicKey, private: privateKey });
    });
  });
};

/**
 * Parses the header part of JWT
 * @param {String} jwt
 * @returns {Object} parsed JWT header
 * @throws {Error} if JWT is malformed
 */
module.exports.parseJwtHeader = function(jwt) {
  const encodedHeader = jwt.split('.', 1)[0];
  try {
    const objStr = Buffer.from(encodedHeader, 'base64').toString('binary');
    return JSON.parse(objStr);
  } catch (err) {
    throw new Error(err.message + ' while decoding JWT header of ' + jwt);
  }
};
