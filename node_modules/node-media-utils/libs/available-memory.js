/// @copyright Â© 2017 Airtime Media.  All rights reserved.

var fs = require('fs');
var os = require('os');
var childProcess = require('child_process');
var util = require('util');

/**
 * gets the current available memory size of the system
 * @param cb (err, availableMemoryInBytes)
 */
exports.availableMemory = function(cb) {
  var pf = os.platform();
  switch (pf) {
    case 'linux':
      fs.readFile('/proc/meminfo', function(err, data) {
        var line = data.toString().split('\n')[2];
        if (!line || 0 !== line.indexOf('MemAvailable:')) {
          return cb(new Error('/proc/meminfo line #2 is not MemAvailable: ' + data));
        }
        var info = line.replace(/ +/g, ' ').split(' ');
        if ('kB' !== info[2]) {
          return cb(new Error('/proc/meminfo has unit other than expected "kB": ' + line));
        }
        var availKB = parseInt(info[1]);
        if (Number.isNaN(availKB)) {
          return cb(new Error('/proc/meminfo has not-a-number MemAvailable value: ' + line));
        }
        return cb(null, availKB * 1024);
      });
      break;

    case 'darwin':
      // helper function
      var elementFromTail = function(array, reverseIndex /* 0, 1, 2 ... */) {
        return array[array.length - reverseIndex - 1];
      }

      childProcess.exec('vm_stat', function(err, stdout, stderr) {
        if (err || stderr) {
          return cb(new Error('Failed to execute vm_stat command: ' + (err ? err : stderr)));
        }
        var stat = stdout.split('\n').slice(0, 8);  // first 8 lines contain all information we need
        if (stat.length < 8) {
          return cb(new Error('vm_stat Does not have enough lines. ' + stdout));
        }
        var pageSizeStr = stat[0].split(' ');
        if (elementFromTail(pageSizeStr, 0) !== 'bytes)') {
          return cb(new Error('vm_stat Could not find page size from output. ' + stdout));
        }
        var pageSize = parseInt(elementFromTail(pageSizeStr, 1));
        if (Number.isNaN(pageSize)) {
          return cb(new Error('vm_stat Could not parse page size. ' + stdout));
        }
        var freePages = parseInt(elementFromTail(stat[1].split(' '), 0));
        if (Number.isNaN(freePages)) {
          return cb(new Error('vm_stat Could not parse free size. ' + stdout));
        }
        var inactivePages = parseInt(elementFromTail(stat[3].split(' '), 0));
        if (Number.isNaN(inactivePages)) {
          return cb(new Error('vm_stat Could not parse inactive size. ' + stdout));
        }
        var purgeablePages = parseInt(elementFromTail(stat[7].split(' '), 0));
        if (Number.isNaN(purgeablePages)) {
          return cb(new Error('vm_stat Could not parse purgeable size. ' + stdout));
        }
        return cb(null, (freePages + inactivePages + purgeablePages) * pageSize);
      });
      break;

    default:
      console.log('Unsupported platform ' + pf + '. Falling back to os.freemem()');
      return cb(null, os.freemem());
  }
}
