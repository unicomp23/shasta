/// @copyright Â© 2015 Airtime Media.  All rights reserved.

/// captures console output (cout, cerr, stdout, stderr) while @a proc is running, @return an array of them.
exports.capture = function(proc) {
  // starts capturing
  exports.prologue();

  // run the proc
  const retVal = proc();
  if (retVal instanceof Promise) {
    return new Promise(resolve => {
      retVal.then(() => {
        // put it back to normal
        resolve(exports.epilogue());
      });
    });
  } else {
    // put it back to normal
    return exports.epilogue();
  }
}

// buffers
var consoleLog = console.log;
var cout = [];
var consoleErr = console.error;
var cerr = [];
var stdout_write = process.stdout.write;
var sout = [];
var stderr_write = process.stderr.write;
var serr = [];

/// start console capturing. need to call epilogue to stop capturing.
exports.prologue = function() {
  consoleLog = console.log;
  cout = [];
  console.log = function(data) {
    cout.push(data);
  }
  consoleErr = console.error;
  cerr = [];
  console.error = function(data) {
    cerr.push(data);
  }
  stdout_write = process.stdout.write;
  sout = [];
  process.stdout.write = function(data) {
    sout.push(data);
  }
  stderr_write = process.stderr.write;
  serr = [];
  process.stderr.write = function(data) {
    sout.push(data);
  }
}

/// stops console capturing and put everything back to normal
exports.epilogue = function() {
  console.error = consoleErr;
  console.log = consoleLog;
  process.stdout.write = stdout_write;
  process.stderr.write = stderr_write;

  return cout.concat(cerr, sout, serr);
}