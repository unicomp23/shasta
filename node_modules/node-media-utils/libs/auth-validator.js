/**
 * @file Provides a reusable mechanism to validate authorization tokens.
 * 
 * @copyright Â© 2020 Airtime Media.  All rights reserved.
 */

var jwt = require('jsonwebtoken');
var util = require('util');
var logger = require('./logging').logger;

/**
 * Error subclass used to inform callers when a token cannot be
 * validated against the provided shared secrets or is otherwise
 * malformed.
 *
 * @param An Error message
 */
exports.BadSignature = function(message) {
  Error.call(this);
  this.message = message;
  this.name = "BadSignature";
}
util.inherits(exports.BadSignature, Error);

/**
 * Error subclass used to inform callers when a token is missing
 * a required field.
 *
 * @param An Error message
 */
exports.MissingField = function(message) {
  Error.call(this);
  this.message = message;
  this.name = "MissingField";
}
util.inherits(exports.MissingField, Error);

/**
 * An authorization class for containing authorization related methods
 *
 */
function Auth() {

}

/**
 * Validates an authorization token against an array of possible shared secrets.
 *
 * @param token encoded JSON Web Token to be validated
 * @param secrets array of shared secret values against which <var>token</var>
 * is to be checked
 * @param cb callback to be invoked when <var>token</var> is validated against
 * a secret (or when it fails to be validated against all of them) 
 * 
 */
Auth.prototype.validate = function(token, secrets, cb) {
  if (secrets.length === 0) {
    // out of secrets
    cb(new exports.BadSignature("Failed to validate auth token"));
  } else {
    var [secret, ...rest] = secrets;
    jwt.verify(token, secret,  { algorithm: 'HS256'}, function (err, decoded) {
      if (err) {
        //  If decode worked but the token is expired, bubble error
        if (err.name == "TokenExpiredError") {
          cb(err);
          return;
        }
        // failed to decode with the first secret; move on to the next
        logger.info("Failed to validate auth token with secret " + secret + ": " + err);
        Auth.prototype.validate(token, rest, cb);
      } else {
        // successfully decoded and validated; need to check for required fields
        if (!decoded.hasOwnProperty('exp')) {
          cb(new exports.MissingField("Missing exp field"));
        }

        // good to go
        cb(null, decoded);
      }
    });
  }
}

var auth = new Auth();
exports.auth = auth;