/**
 * Logging throughout the app. Use like this in any file:
 * @example
 *   var logger = require('./logging.js').logger;
 *   logger.info('log message!');
 *
 * Alternatively, you can have your own logger instance
 * that can add your specific tag everytime you log.
 *   var Logger = require('.logging.js').Logger;
 *   var logger = new Logger(<tag>);
 *   <tag> is shown in all log entries.
 * You can change the tag later.
 *   logger.tag = <new tag>;
 *
 * In your main app you must call:
 *    var options = { ... };
 *    require('./logging.js').init<LogType>Logger(options);
 * in startup somewhere,
 * where <LogType> can be [Console|File|SysLog].
 * See available options listed at the function.
 *
 * Optionally, you can change log level by calling
 *    var level = 'debug';
 *    set<LogType>LogLevel(level);
 * @see LogLevels for available levels.
 *
 * @copyright
 * Copyright Airtime Media, 2014
 */
var winston = require('winston');
var Syslog = require('modern-syslog');
var path = require('path');

// Logger

function Logger(tag) {
  this.tag = tag;
}
exports.Logger = Logger;

// exposing internal for testing
Logger.loggerClass_ = winston;
Logger.sysLogClass_ = Syslog;

// precrated instance
var logger = new Logger();
exports.logger = logger;


var to2digit = function(num) {  // positive only
  if (num < 0) throw new Error("positive only");
  if (num < 10) {
    return '0' + num.toString();
  }
  return num.toString();
}
var to3digit = function(num) {  // positive only
  if (num < 100) {
    return '0' + to2digit(num);
  }
  return num.toString();
}

// Timestamp for log statements.
function logTimestamp() {
  var now = new Date();
  return now.getUTCFullYear().toString() + '/' + to2digit(now.getUTCMonth()+1) + '/' + to2digit(now.getUTCDate())
       + ' ' + to2digit(now.getUTCHours()) + ':' + to2digit(now.getUTCMinutes()) + ':' + to2digit(now.getUTCSeconds())
       + '.' + to3digit(now.getUTCMilliseconds());
}

/// Log levels and colors.
var LogLevels = {
  levels: {
    silly: 0,
    verbose: 1,
    debug: 2,
    info: 3,
    warn: 4,
    error: 5,
    none: 1000  // only to set minimum log level
  },
  colors: {
    silly: 'black',
    verbose: 'black',
    debug: 'blue',
    info:  'green',
    warn:  'magenta',
    error: 'red'
  }
}

// TEC-853: In order to share logging settings among all modules, the settings are stored in 'global' object.
if (!global.at_node_media_utils_logging_options) {  // unless somebody else has initialized it already...
  global.at_node_media_utils_logging_options = { Console: {}, File: {}, SysLog: {} };
}
var options = global.at_node_media_utils_logging_options;

var HandleSpecificOptions = {
  Console: function(opt) {
    if (!opt.colorize)
      opt.colorize = true;
  },
  File: function(opt) {
    if (!opt.filename)
      throw new Error("File logger needs filename");
  },
  SysLog: function(opt) {
    if (!opt.name)
      throw new Error("SysLog logger needs name");
  }
}

var syslogLevels_ = {
  error: Syslog.LOG_ERR,
  warn: Syslog.LOG_WARNING,
  info: Syslog.LOG_INFO,
  debug: Syslog.LOG_DEBUG,
  verbose: null,
  silly: null
};

var init_ = function() {
  if (!global.at_node_media_utils_logging_initialized_) {
    global.at_node_media_utils_logging_initialized_ = true;
    Logger.loggerClass_.addColors(LogLevels.colors);
    Logger.loggerClass_.setLevels(LogLevels.levels);
  }
}

var setDefaultLogOptions = function(opt) {
  if (!opt.timestamp) opt.timestamp = logTimestamp;
  var logLevel = opt.level || 'info';
  if (!opt.level) opt.level = logLevel;
}

Object.keys(options).forEach(function(type) {
  /*
   * init[Console|File|SysLog]Logger(option)
   *  for Console:
   *    option = {
   *      timestamp: <func>, (optional. default is in UTC: YY/MM/DD hh:mm:ss.mmm)
   *      level: <see LogLevels above>, (optional, default is 'info')
   *      colorize: <...> (optional)
   *    }
   *  for File:
   *    option = {
   *      filename: <filename>, (required)
   *      timestamp: <func>, (optional)
   *      maxsize: <# of bytes to rotate>, (optional)
   *      maxFiles: <# of log files>, (optional)
   *      level: <see LogLevels above> (optional)
   *    }
   *  for SysLog:
   *    option = {
   *      name: <name>, (required)
   *      level: <see LogLevels above> (optional)
   *    }
   */
  exports.Logger['init' + type + 'Logger'] = function(opt) {
    init_();
    options[type] = opt || {};
    setDefaultLogOptions(options[type]);
    HandleSpecificOptions[type].call(this, options[type]);
    if ('SysLog' == type) {
      Logger.sysLogClass_.init(options[type].name, Syslog.LOG_PID | Syslog.LOG_ODELAY, Syslog.LOG_LOCAL0);
      global.at_node_media_utils_logging_use_syslog_ = true;
    } else {
      try {
        Logger.loggerClass_.remove(winston.transports[type]);
      } catch(err) {}
      Logger.loggerClass_.add(winston.transports[type], options[type]);
    }
    logger.info('initialized ' + type + ' logger to level ' + options[type].level);
  };

  /*
   * set[Console|File|SysLog]LogLevel(level)
   *  @param level: see LogLevels above
   *  @return previous level
   */
  exports.Logger['set' + type + 'LogLevel'] = function(level) {
    if (0 == Object.keys(options[type]).length) {
      throw new Error(type + ' logger is not initialized');
    }
    var prev = options[type].level.slice(0);
    options[type].level = level;
    exports.Logger['init' + type + 'Logger'](options[type]);
    return prev;
  };
});

var findPositionsInStack = function(stack) {
  var line2start = stack.indexOf('\n') + 1; // eliminates 'Error\n'
  var line3start = stack.indexOf('\n', line2start) + 1; // eliminates log func
  var line3end = stack.indexOf('\n', line3start);
  if (line3end < 0) line3end = stack.length;  // in case line 3 does not have \n i.e. it is the last line
  var lineNoEndPos = stack.lastIndexOf(':', line3end);
  var fileNamePos = stack.lastIndexOf('/', line3end);
  if (-1 == fileNamePos) fileNamePos = line3start;
  else ++fileNamePos;  // remove '/'
  return [line3start, fileNamePos, lineNoEndPos];
}

/*
 * logger.<level>(message)
 * Note: silly and verbose do not write to SysLog.
 */
Object.keys(LogLevels.colors).forEach(function(level) {
  Logger.prototype[level] = function(msg) {
    var stack = new Error().stack;
    var positions = findPositionsInStack(stack);
    var msgPrefix = '[' + stack.slice(positions[1], positions[2]) + '] ';
    if (this.tag) msgPrefix += '[' + this.tag + '] ';
    if ('error' == level) {
      msg += '\n' + stack.slice(positions[0]);
    }

    Logger.loggerClass_[level](msgPrefix + msg);

    if (global.at_node_media_utils_logging_use_syslog_) {
      var minLevel = LogLevels.levels[options.SysLog.level];
      if (minLevel === undefined) minLevel = LogLevels.levels.none;
      var logLevel = LogLevels.levels[level];
      if (logLevel === undefined) logLevel = LogLevels.levels.silly;
      if (minLevel <= logLevel) {
        var syslogLevel = syslogLevels_[level];
        if (syslogLevel) {
          Logger.sysLogClass_.log(syslogLevel, '<'+level+'>' + logTimestamp() + msgPrefix + msg); // UTC with milli second
        }
      }
    }
  }
});

/**
 * Sets up logger (maybe temporarily)
 * Enables console logger and syslog logger with info level.
 */
Logger.enableTemporaryLog = function() {
  Logger.initSysLogLogger({name: path.basename(process.argv[1]).split('.')[0],  // main JS file name
                           level: 'info'});
  Logger.initConsoleLogger({level: 'info'});
};
