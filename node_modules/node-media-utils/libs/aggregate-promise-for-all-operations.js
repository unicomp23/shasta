// Copyright Airtime Media, 2022

const { Logger } = require('./logging')
const logger = new Logger('aggregatePromiseForAllOperations');

/**
 * @class PromiseCompleter
 * Used to complete (or fail) an operational promise
 */
const PromiseCompleter = function(resolve, reject){
  this.resolve = resolve;
  this.reject = reject;
};

PromiseCompleter.prototype.resolve = function(val) {
  this.resolve(val);
};

PromiseCompleter.prototype.reject = function(err) {
  this.reject(err);
};

/**
 * @class PromiseAggregator
 * Controls aggregation of promises.
 */
const PromiseAggregator = function() {
  this.aggregatedPromises = [];
  this.aggregationPromise = new Promise((resolve, reject) => {
    this.aggregationResolve = resolve;
    this.aggregationReject = reject;
  });
};

/// Adds a new operational promise. @returns completer object that has resolve(val) and reject(err)
PromiseAggregator.prototype.add = function() {
  if (this.aggregationCompleted()) throw new Error('Cannot add after done or failedToAggregate');
  let completer;
  const promise = new Promise((resolve, reject) => {
    completer = new PromiseCompleter(resolve, reject);
  });
  this.aggregatedPromises.push(promise);
  return completer;
};

/// Tells the aggregation completed.
PromiseAggregator.prototype.done = function() {
  // if double call happened, it is too late to throw.
  // aggregatePromiseForAllOperations has already proceeded past waiting aggregationPromise.
  // thus error log that can show stack trace
  if (this.aggregationCompleted()) {
    logger.error('done is called after done or failedToAggregate has already called');
    return;
  }
  this.aggregationDone = true;
  this.aggregationResolve();
};

/// Tells the aggregation failed. aggregatePromiseForAllOperations fails immediately.
PromiseAggregator.prototype.failedToAggregate = function(err) {
  // if double call happened, it is too late to throw.
  // aggregatePromiseForAllOperations has already proceeded past waiting aggregationPromise.
  // thus error log that can show stack trace
  if (this.aggregationCompleted()) {
    logger.error('failedToAggregate is called after done or failedToAggregate has already called');
    return;
  }
  this.aggregationFailed = true;
  this.aggregationReject(err);
};

PromiseAggregator.prototype.aggregationCompleted = function() {
  return this.aggregationDone || this.aggregationFailed;
};


/**
 * Let @a processFn aggregate its operational promises into @a aggregator
 * then let @a resultFn decide the result value (or promise)
 * @param {Function} processFn takes (aggregator). See example usage below.
 * @param {Function} resultFn takes (aggregatedPromises :an array of promises) after all promises
 * aggregated in @a processFn have been fulfilled.
 * Then @a resultFn returns a promise or an immediate value that becomes a return value
 * of this function.
 * If not given, undefined is returned.
 * @returns the return value from @a resultFn.
 * @throws if @a processFn or @a resultFn threw, or if any promise added to @a promises is rejected.
 *
 * Example:
 * <pre>
 * someFunction()
 *   return aggregatePromiseForAllOperations(
 *     (aggregator => {
 *        // to add a operational promise
 *        const completer = aggregator.add();
 *        // later maybe async
 *        completer.resolve(someValue);
 *        // or
 *        completer.reject(someError);
 *        // then after adding all operational promises
 *        aggregator.done();
 *        // of if it failed to add all operational promises
 *        aggregator.failedToAggregate(someError);
 *      },
 *      (aggregatedPromises => {
 *   });
 * };
 * </pre>
 */
module.exports.aggregatePromiseForAllOperations = async function(processFn, resultFn) {
    const aggregator = new PromiseAggregator();
    processFn(aggregator);

    // wait for the promises aggregation (collected in the processFn) completes
    // so that aggregator.aggregatedPromises has all of them.
    await aggregator.aggregationPromise;
    await Promise.all(aggregator.aggregatedPromises);
    return resultFn ? await resultFn(aggregator.aggregatedPromises) : undefined;
}
