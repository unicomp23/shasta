/// @copyright Â© 2022 Airtime Media.  All rights reserved.

var chai = require('chai');
var expect = chai.expect;
chai.config.includeStack = true;

const Logger = require('../libs/logging').Logger;
const LocalTestServer = require('./local-test-server').LocalTestServer;
const HttpRequest = require('../libs/http-request').HttpRequest;

describe('HttpRequest', function() {
  before(function() {
    Logger.initConsoleLogger({ level: 'debug' });
  });
  after(function() {
    Logger.initConsoleLogger({ level: 'error' });
  });

  it('should keep alive among requests', async function() {
    const localServer = new LocalTestServer();

    const resStat1 = 201;
    const resObj1 = { data: 'data1' };

    const resStat2 = 202;
    const resObj2 = "data2";

    let [ server, port ] = await(localServer.run([
      { statusCode: resStat1, body: resObj1 },
      { statusCode: resStat2, body: resObj2 }
    ]));
    const req = new HttpRequest('localhost', port, 'http', {
      keepAlive: true
    });

    const reqObj1 = { data: 'req-data-1' };
    const res1 = await req.send('post', '/path1', reqObj1, {
      headers: {
        authorization: 'auth1'
      }
    });
    expect(res1.statusCode).to.equal(resStat1);
    expect(res1.statusMessage).to.equal('status=' + resStat1);  // see LocalTestServer
    expect(res1.headers['content-type']).to.equal('application/json');
    expect(res1.body).to.deep.equal(resObj1);
    expect(localServer.requests.length).to.equal(1);
    expect(localServer.requests[0].headers.authorization).to.equal('auth1');
    expect(localServer.requests[0].headers.connection).to.equal('keep-alive');
    expect(localServer.requestBodies.length).to.equal(1);
    expect(localServer.requestBodies[0]).to.equal(JSON.stringify(reqObj1));
    expect(localServer.connected).to.be.true;
    expect(localServer.closed).to.be.not.ok;

    const reqObj2 = 'req-data-2';
    const res2 = await req.send('Post', '/path2', reqObj2, {
      headers: {
        authorization: 'auth2'
      }
    });
    expect(res2.statusCode).to.equal(resStat2);
    expect(res2.statusMessage).to.equal('status=' + resStat2);  // see LocalTestServer
    expect(res2.headers['content-type']).to.equal('text/html');
    expect(res2.body).to.deep.equal(resObj2);
    expect(localServer.requests.length).to.equal(2);
    expect(localServer.requests[1].headers.authorization).to.equal('auth2');
    expect(localServer.requests[1].headers.connection).to.equal('keep-alive');
    expect(localServer.requestBodies.length).to.equal(2);
    expect(localServer.requestBodies[1]).to.equal(reqObj2);
    expect(localServer.connected).to.be.true;
    expect(localServer.closed).to.be.not.ok;
  });

  it('should close requests', async function() {
    const localServer = new LocalTestServer();

    const resStat1 = 201;
    const resObj1 = { data: 'data1' };

    const resStat2 = 202;
    const resObj2 = "data2";

    let [ server, port ] = await(localServer.run([
      { statusCode: resStat1, body: resObj1 },
      { statusCode: resStat2, body: resObj2 }
    ]));
    const req = new HttpRequest('localhost', port, 'http', {
      keepAlive: false
    });

    const reqObj1 = { data: 'req-data-1' };
    const res1 = await req.send('poST', '/path1', reqObj1, {
      headers: {
        authorization: 'auth1'
      }
    });
    expect(res1.statusCode).to.equal(resStat1);
    expect(res1.headers['content-type']).to.equal('application/json');
    expect(res1.body).to.deep.equal(resObj1);
    expect(localServer.requests.length).to.equal(1);
    expect(localServer.requests[0].headers.authorization).to.equal('auth1');
    expect(localServer.requests[0].headers.connection).to.equal('close');
    expect(localServer.requestBodies.length).to.equal(1);
    expect(localServer.requestBodies[0]).to.equal(JSON.stringify(reqObj1));
    expect(localServer.connected).to.be.true;
    expect(localServer.closed).to.be.not.true;

    localServer.connected = undefined;
    localServer.closed = undefined;

    const reqObj2 = 'req-data-2';
    const res2 = await req.send('post', '/path2', reqObj2, {
      headers: {
        authorization: 'auth2'
      }
    });
    expect(res2.statusCode).to.equal(resStat2);
    expect(res2.headers['content-type']).to.equal('text/html');
    expect(res2.body).to.deep.equal(resObj2);
    expect(localServer.requests.length).to.equal(2);
    expect(localServer.requests[1].headers.authorization).to.equal('auth2');
    expect(localServer.requests[1].headers.connection).to.equal('close');
    expect(localServer.requestBodies.length).to.equal(2);
    expect(localServer.requestBodies[1]).to.equal(reqObj2);
    expect(localServer.connected).to.be.true;
    expect(localServer.closed).to.be.not.ok;
  });

  // the reason of having this test is that Axios has different handling method for
  // put, post, patch from other methods. Others do not take request body.
  it('should get', async function() {
    const localServer = new LocalTestServer();

    const resStat1 = 201;
    const resObj1 = { data: 'data1' };
    const cacheCtrl = 'maxage=123';

    let [ server, port ] = await(localServer.run([
      { statusCode: resStat1, body: resObj1, headers: {'cache-control': cacheCtrl} }
    ]));
    const req = new HttpRequest('localhost', port, 'http', {
      keepAlive: false
    });

    const reqObj1 = { data: 'req-data-1' };
    const res1 = await req.send('get', '/path1', reqObj1, {
      headers: {
        authorization: 'auth1'
      }
    });
    expect(res1.statusCode).to.equal(resStat1);
    expect(res1.headers['content-type']).to.equal('application/json');
    expect(res1.headers['cache-control']).to.equal(cacheCtrl);
    expect(res1.body).to.deep.equal(resObj1);
    expect(localServer.requests.length).to.equal(1);
    expect(localServer.requests[0].headers.authorization).to.equal('auth1');
    expect(localServer.requests[0].headers.connection).to.equal('close');
    expect(localServer.requestBodies.length).to.equal(1);
    expect(localServer.requestBodies[0]).to.equal(JSON.stringify(reqObj1));
  });

  it('should ok with no opts', async function() {
    const localServer = new LocalTestServer();

    const resStat1 = 201;
    const resObj1 = { data: 'data1' };

    let [ server, port ] = await(localServer.run([
      { statusCode: resStat1, body: resObj1 }
    ]));
    const req = new HttpRequest('localhost', port, 'http', {
      keepAlive: false
    });

    const reqObj1 = { data: 'req-data-1' };
    const res1 = await req.send('get', '/path1', reqObj1);
    expect(res1.statusCode).to.equal(resStat1);
    expect(res1.headers['content-type']).to.equal('application/json');
    expect(res1.body).to.deep.equal(resObj1);
    expect(localServer.requests.length).to.equal(1);
    expect(localServer.requestBodies.length).to.equal(1);
    expect(localServer.requestBodies[0]).to.equal(JSON.stringify(reqObj1));
  });

  it('should ok with no body, no opts', async function() {
    const localServer = new LocalTestServer();

    const resStat1 = 201;
    const resObj1 = { data: 'data1' };

    let [ server, port ] = await(localServer.run([
      { statusCode: resStat1, body: resObj1 }
    ]));
    const req = new HttpRequest('localhost', port, 'http', {
      keepAlive: false
    });

    const res1 = await req.send('get', '/path1');
    expect(res1.statusCode).to.equal(resStat1);
    expect(res1.headers['content-type']).to.equal('application/json');
    expect(res1.body).to.deep.equal(resObj1);
    expect(localServer.requests.length).to.equal(1);
    expect(localServer.requestBodies.length).to.equal(1);
    expect(localServer.requestBodies[0]).to.be.empty;
  });

  it('should handle GET error response case', async function() {
    const localServer = new LocalTestServer();

    const resStat1 = 401;

    let [ server, port ] = await(localServer.run([
      { statusCode: resStat1 }
    ]));
    const req = new HttpRequest('localhost', port, 'http');

    let thrown = false;
    try {
      await req.send('geT', '/path1');
    } catch (err) {
      thrown = true;
      expect(err.message).to.be.not.empty;
    }
    expect(thrown).to.be.true;
  });

  it('should handle POST error response case', async function() {
    const localServer = new LocalTestServer();

    const resStat1 = 401;

    let [ server, port ] = await(localServer.run([
      { statusCode: resStat1 }
    ]));
    const req = new HttpRequest('localhost', port, 'http');

    let thrown = false;
    try {
      await req.send('post', '/path1');
    } catch (err) {
      thrown = true;
      expect(err.message).to.be.not.empty;
    }
    expect(thrown).to.be.true;
  });

  it('should use httpOptions given to the constructor', async function() {
    const localServer = new LocalTestServer();

    const resStat1 = 401;

    let [ server, port ] = await(localServer.run([
      { statusCode: resStat1 }
    ]));
    const req = new HttpRequest('localhost', port, 'http', null /* agentOption */, {
      validateStatus: null  // do not throw on non 2xx status
    });

    let thrown = false;
    try {
      await req.send('post', '/path1');
    } catch (err) {
      thrown = true;
      expect(err.message).to.be.not.empty;
    }
    expect(thrown).to.be.false;
  });

  it('should override httpOptions given to the constructor by the one given to send', async function() {
    const localServer = new LocalTestServer();

    const resStat1 = 401;

    let [ server, port ] = await(localServer.run([
      { statusCode: resStat1 }
    ]));
    const req = new HttpRequest('localhost', port, 'http', null /* agentOption */, {
      validateStatus: null  // do not throw on non 2xx status
    });

    let thrown = false;
    try {
      await req.send('post', '/path1', null /* body */, {
        validateStatus: (status => 200 === status)  // throw if not 200
      });
    } catch (err) {
      thrown = true;
      expect(err.message).to.be.not.empty;
    }
    expect(thrown).to.be.true;
  })
});