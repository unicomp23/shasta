/// @copyright Â© 2015 Airtime Media.  All rights reserved.

var util = require('../libs/util');

// Mock
/**
 * @param test: an object that has ok(<bool>, <msg>), equal(<obj1>, <obj2>, <msg>)
 */
var Mock = function(test) {
  // public properties
  this.trace = false;

  var caller = new Error('dummy').stack.split('\n')[2].split('/').reverse()[0];  // contains last ')'
  this.id = caller.substr(0, caller.length - 1);

  // private stuff
  this.test_ = test;
  this.expectations_ = {};
  this.sequence_ = [];
  this.sequenceNo_ = 0;
};
exports.Mock = Mock;

var Expectation = function(funcs) {
  this.funcs = funcs;
};
Expectation.prototype.thenDo = function(fnc) {
  this.funcs[this.funcs.length - 1] = fnc;
};
Mock.prototype.expects = function(name) {
  this.sequence_.push(name);
  if (!this.expectations_[name]) {
    this.expectations_[name] = {};
    var prop = this.expectations_[name];
    prop.funcs = [];
    prop.count = 0;
    if (this[name]) {
      console.log(this.id + '-' + 'Name batting with mock method ' + name);
    }
    this[name] = function() {
      var args = [].slice.apply(arguments);
      if (this.trace) {
        console.log(this.id + '-' + name + util.inspect(args));
      }
      this.test_.ok(this.sequenceNo_ < this.sequence_.length,
                  this.id + '-' +
                  'Mock does not expect any more calls but called ' + name + util.inspect(args));
      this.test_.equal(name, this.sequence_[this.sequenceNo_],
                  this.id + '-' +
                  'Mock calling sequence error. expected ' + this.sequence_[this.sequenceNo_] +
                  ' but called ' + name + util.inspect(args));
      ++this.sequenceNo_;
      this.test_.ok(prop.count < prop.funcs.length,
                  this.id + '-' +
                  'Mock method ' + name + ' does not expect any more calls but called with ' + util.inspect(args));
      return prop.funcs[prop.count++].apply(this, arguments);
    };
  }
  var funcs = this.expectations_[name].funcs;
  funcs.push( function(){} );  // to make thenDo optional
  return new Expectation(funcs);
};

Mock.prototype.verify = function() {
  var methods = Object.keys(this.expectations_);
  for (var i = 0; i < methods.length; ++i) {
    var method = this.expectations_[methods[i]];
    if (this.trace) {
      if (method.count !== method.funcs.length) {
        console.log(this.id + '-' + 'Verify Not OK: ' +
          methods[i] + ' call expected ' + method.funcs.length + ' times but called ' + method.count + ' times');
      } else {
        console.log(this.id + '-' + 'Verify OK: ' + methods[i] + ' called ' + method.count + ' times');
      }
    }
    this.test_.equal(method.count, method.funcs.length,
                     this.id + '-' +
                     'Mock verification error. method ' + methods[i] + ' expected ' + method.funcs.length +
                     ' calls but called only ' + method.count + ' times.');
  }
};

