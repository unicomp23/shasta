// Copyright Airtime Media, 2022

var chai = require('chai');
var expect = chai.expect;
chai.config.includeStack = true;

const { aggregatePromiseForAllOperations } = require('../libs/aggregate-promise-for-all-operations.js');
const { Logger } = require('../libs/logging');
const ConsoleCapture = require('../libs/console-capture');


describe('aggregatePromiseForAllOperations', function() {
  it('should aggregate into one promise and return custom result', async function() {
    const completed = [];
    const numOps = 5;
    const delays = [ 10, 2, 6, 4, 8 ];
    const procFn = (aggregator) => {
      for (let i = 0; i < numOps; ++i) {
        // the proc can be async
        setTimeout(() => {
          const completer = aggregator.add();
          setTimeout(() => {
            completed.push(i);
            completer.resolve(i * 10);
          }, delays[i]);
          if (i === numOps - 1) aggregator.done();
        }, 2);
      }
    };
    let peekedPromises;
    const resultFn = (promises) => {
      peekedPromises = promises;
      return promises.length;
    };

    const result = await aggregatePromiseForAllOperations(procFn, resultFn);
    expect(result).to.equal(numOps);
    expect(completed.length).to.equal(numOps);
    for (let i = 0; i < numOps; ++i) {  // completed values are in completion order
      expect(completed).to.contain(i);
    }
    expect(peekedPromises.length).to.equal(numOps);
    for (let i = 0; i < numOps; ++i) {  // promises are in push order
      expect(await peekedPromises[i]).to.equal(i * 10);
    }
  });

  it('should aggregate into one promise and return no result if no resultFn', async function() {
    const completed = [];
    const numOps = 5;
    const delays = [ 10, 2, 6, 4, 8 ];
    const procFn = (aggregator) => {
      // the proc can be async
      setTimeout(() => {
        for (let i = 0; i < numOps; ++i) {
          const completer = aggregator.add();
          setTimeout(() => {
            completed.push(i);
            completer.resolve(i * 10);
          }, delays[i]);
        }
        aggregator.done();
      }, 2);
    };

    const result = await aggregatePromiseForAllOperations(procFn);
    expect(result).to.be.undefined;
    expect(completed.length).to.equal(numOps);
    for (let i = 0; i < numOps; ++i) {  // completed values are in completion order
      expect(completed).to.contain(i);
    }
  });

  it('should reject if op failed', async function() {
    const numOps = 5;
    const finalError = 'final thing';
    const testFn = (aggregator) => {
      for (let i = 0; i < numOps; ++i) {
        setTimeout(() => {
          switch (i) {
          case 3: {
            const completer = aggregator.add();
            setTimeout(() => {
              completer.reject(new Error(finalError));
            }, 10);
            break;
          }
          case 0: case 1: case 2: {
            const completer = aggregator.add();
            setTimeout(() => {
              completer.resolve();
            }, 2);
            break;
          }
          case 4:
            aggregator.done();
            break;
          }
        }, 2);
      }
    };

    // Note: chai's .to.throw cannot catch promise rejection
    let thrown = false;
    try {
      await aggregatePromiseForAllOperations(testFn);
    } catch (err) {
      thrown = true;
      expect(err.message).to.contain(finalError);
    }
    expect(thrown).to.be.true;
  });

  it('should reject if function failed to aggregate promises', async function() {
    const finalError = 'final thing';
    const testFn = (aggregator) => {
      aggregator.failedToAggregate(new Error(finalError));
    };

    // Note: chai's .to.throw cannot catch promise rejection
    let thrown = false;
    try {
      await aggregatePromiseForAllOperations(testFn);
    } catch (err) {
      thrown = true;
      expect(err.message).to.contain(finalError);
    }
    expect(thrown).to.be.true;
  });

  it('should throw if aggregator.add is called after done call', async function() {
    const testFn = (aggregator) => {
      const completer1 = aggregator.add();
      completer1.resolve(1);
      aggregator.done();
      aggregator.add();
    };
    let thrown = false;
    try {
      await aggregatePromiseForAllOperations(testFn);
    } catch (err) {
      thrown = true;
      expect(err.message).to.contain('Cannot add after done or failedToAggregate');
    }
    expect(thrown).to.be.true;
  });

  it('should throw if aggregator.add is called after failedToAggregate call', async function() {
    const testFn = (aggregator) => {
      const completer1 = aggregator.add();
      completer1.resolve(1);
      aggregator.failedToAggregate();
      aggregator.add();
    };
    let thrown = false;
    try {
      await aggregatePromiseForAllOperations(testFn);
    } catch (err) {
      thrown = true;
      expect(err.message).to.contain('Cannot add after done or failedToAggregate');
    }
    expect(thrown).to.be.true;
  });

  describe('error log tests', function() {
    it('should log if done is called twice', async function() {
      // the second done call is after returning from aggregatePromiseForAllOpreations function.
      // so an error log is the only way to express the error
      const testFn = (aggregator) => {
        const completer1 = aggregator.add();
        completer1.resolve(1);
        aggregator.done();
        setTimeout(() => {
          aggregator.done();
        }, 3);
      };

      const out = await ConsoleCapture.capture(async() => {
        await aggregatePromiseForAllOperations(testFn);
        // extra wait time for the error to happen after return
        await new Promise(resolve => { setTimeout(() => { resolve(); }, 10); });
      });
      expect(out[0]).to.contain('done is called after done or failedToAggregate has already called');
      expect(out[0]).to.contain(__filename);
    });

    it('should log if failedToAggregate is called twice', async function() {
      // the second done call is after returning from aggregatePromiseForAllOpreations function.
      // so an error log is the only way to express the error
      const testFn = (aggregator) => {
        const completer1 = aggregator.add();
        completer1.resolve(1);
        aggregator.failedToAggregate(10);
        setTimeout(() => {
          aggregator.failedToAggregate(20);
        }, 3);
      };

      const out = await ConsoleCapture.capture(async() => {
        try {
          await aggregatePromiseForAllOperations(testFn);
        } catch (err) {}
        // extra wait time for the error to happen after return
        await new Promise(resolve => { setTimeout(() => { resolve(); }, 10); });
      });
      expect(out[0]).to.contain('failedToAggregate is called after done or failedToAggregate has already called');
      expect(out[0]).to.contain(__filename);
    });
  });
});
