/// @copyright Â© 2017 Airtime Media.  All rights reserved.

var chai = require('chai');
var assert = chai.assert;
chai.config.includeStack = true;

var DelayExecutionQueue = require('../libs/delay-execution-queue').DelayExecutionQueue;

describe('DelayExecutionQueue', function() {

  it('should throw if delay time is not given', function(done) {
    try {
      new DelayExecutionQueue();
      assert.ok(false, 'should throw');
    } catch (err) {
      assert.ok(err instanceof Error, err);
      assert.ok(0 <= err.toString().indexOf('delayMs'), err);
    }
    done();
  });

  it('should throw if delay time is negative', function(done) {
    try {
      new DelayExecutionQueue(-33);
      assert.ok(false, 'should throw');
    } catch (err) {
      assert.ok(err instanceof Error, err);
      assert.ok(0 <= err.toString().indexOf('delayMs'), err);
    }
    done();
  });

  it('should throw if queueMax is negative', function(done) {
    try {
      new DelayExecutionQueue(10, -33, DelayExecutionQueue.kDropOldestUponFull);
      assert.ok(false, 'should throw');
    } catch (err) {
      assert.ok(err instanceof Error, err);
      assert.ok(0 <= err.toString().indexOf('queueMax'), err);
    }
    done();
  });

  it('should throw if dropOnMaxPolicy is missing', function(done) {
    try {
      new DelayExecutionQueue(10, 3);
      assert.ok(false, 'should throw');
    } catch (err) {
      assert.ok(err instanceof Error, err);
      assert.ok(0 <= err.toString().indexOf('dropOnMaxPolicy'), err);
    }
    done();
  });

  it('should throw if dropOnMaxPolicy is incorrect', function(done) {
    try {
      new DelayExecutionQueue(10, 3, 100);
      assert.ok(false, 'should throw');
    } catch (err) {
      assert.ok(err instanceof Error, err);
      assert.ok(0 <= err.toString().indexOf('dropOnMaxPolicy'), err);
    }
    done();
  });

  it('should execute the first closure immediately', function(done) {
    var delayMs = 100;
    var dq = new DelayExecutionQueue(delayMs);

    var start = Date.now();
    dq.push(function() {
      var executed = Date.now();

      assert.isAbove(executed, 0);
      assert.isBelow(executed - start, 10);

      // nothing queued
      assert.equal(dq.queue_.length, 0);

      done();
    });
  });

  it('should execute the first closure immediately and second after delay', function(done) {
    var delayMs = 100;
    var dq = new DelayExecutionQueue(delayMs);

    var start = Date.now();

    dq.push(function() {
      var executed1 = Date.now();
      assert.isAbove(executed1, 0);
      assert.isBelow(executed1 - start, 10);
    });

    dq.push(function() {
      var executed2 = Date.now();

      // the second closure must be executed after 'delay'
      assert.isAbove(executed2, 0);
      assert.isBelow(executed2 - start, delayMs + 10);

      // the queue is empty now
      assert.equal(dq.queue_.length, 0);

      done();
    });

    // the second was queued
    assert.equal(dq.queue_.length, 1);
  });

  it('should execute four closures, each given in interval shorter than delay, in delay interval', function(done) {
    var delayMs = 100;
    var dq = new DelayExecutionQueue(delayMs);

    var start = Date.now();

    dq.push(function() {
      var executed1 = Date.now();
      assert.isAbove(executed1, 0);
      assert.isBelow(executed1 - start, 10);
    });

    setTimeout(function() {
      dq.push(function() {
        var executed2 = Date.now();
        // the second closure must be executed after 'delay'
        assert.isAbove(executed2 - start, delayMs - 10);
        assert.isBelow(executed2 - start, delayMs + 10);
      });

      setTimeout(function() {
        dq.push(function() {
          var executed3 = Date.now();
          // the 3rd closure must be executed after 'delay'
          assert.isAbove(executed3 - start, (delayMs - 10) * 2);
          assert.isBelow(executed3 - start, (delayMs + 10) * 2);  // node js interval timer accumurates errors
        });

        setTimeout(function() {
          dq.push(function() {
            var executed4 = Date.now();
            // the 4th closure must be executed after 'delay'
            assert.isAbove(executed4 - start, (delayMs - 10) * 3);
            assert.isBelow(executed4 - start, (delayMs + 10) * 3);

            // see how much interval timer error accumurated
            // console.log('total delay ' + (executed4 - start) + ' supposed to be ' + (delayMs * 3));

            // the queue is empty now
            assert.equal(dq.queue_.length, 0);

            done();
          });
        }, delayMs / 2);
      }, delayMs / 2);
    }, delayMs / 2);
  });

  it('should execute three closures immediately, each given in interval longer than delay', function(done) {
    var delayMs = 100;
    var dq = new DelayExecutionQueue(delayMs);

    var start1 = Date.now();
    dq.push(function() {
      var executed1 = Date.now();
      assert.isAbove(executed1, 0);
      assert.isBelow(executed1 - start1, 10);
    });

    setTimeout(function() {
      var start2 = Date.now();
      dq.push(function() {
        var executed2 = Date.now();
        // no delay
        assert.isAbove(executed2, 0);
        assert.isBelow(executed2 - start2, 10);
      });

      setTimeout(function() {
        var start3 = Date.now();
        dq.push(function() {
          var executed3 = Date.now();
          // no delay
          assert.isAbove(executed3, 0);
          assert.isBelow(executed3 - start3, 10);

          // the queue is empty now
          assert.equal(dq.queue_.length, 0);

          done();
        });
      }, delayMs + 10);
    }, delayMs + 10);
  });

  it('should drop the oldest entry if exceeds max entries', function(done) {
    var delayMs = 100;
    var max = 2;
    var policy = DelayExecutionQueue.kDropOldestUponFull;
    var dq = new DelayExecutionQueue(delayMs, max, policy);

    // this closure is not queued
    var start1 = Date.now();
    dq.push(function() {
      var executed1 = Date.now();
      assert.isAbove(executed1, 0);
      assert.isBelow(executed1 - start1, 10);
    });

    // this closure will be dropped
    dq.push(function() {
      assert.fail("should not run");
    });

    // so this should run after the first delay
    var start2 = Date.now();
    dq.push(function() {
      var executed3 = Date.now();
      assert.isAbove(executed3 - start2, delayMs - 10);
      assert.isBelow(executed3 - start2, delayMs + 10);
    });

    // this push causes the first queue entry dropped, and itself will be executed later
    var start3 = Date.now();
    dq.push(function() {
      var executed4 = Date.now();
      assert.isAbove(executed4 - start3, (delayMs - 10) * 2);
      assert.isBelow(executed4 - start3, (delayMs + 10) * 2);

      // the queue is empty now
      assert.equal(dq.queue_.length, 0);

      done();
    });
  });

  it('should drop the latest entry if exceeds max entries', function(done) {
    var delayMs = 100;
    var max = 2;
    var policy = DelayExecutionQueue.kDropLatestUponFull;
    var dq = new DelayExecutionQueue(delayMs, max, policy);

    // this closure is not queued
    var start1 = Date.now();
    dq.push(function() {
      var executed1 = Date.now();
      assert.isAbove(executed1, 0);
      assert.isBelow(executed1 - start1, 10);
    });

    var start2 = Date.now();
    dq.push(function() {
      var executed2 = Date.now();
      assert.isAbove(executed2 - start2, delayMs - 10);
      assert.isBelow(executed2 - start2, delayMs + 10);
    });

    // this closure will be dropped
    dq.push(function() {
      assert.fail("should not run");
    });

    // this push causes the last queue entry dropped, and itself will be executed later
    var start3 = Date.now();
    dq.push(function() {
      var executed4 = Date.now();
      assert.isAbove(executed4 - start3, (delayMs - 10) * 2);
      assert.isBelow(executed4 - start3, (delayMs + 10) * 2);

      // the queue is empty now
      assert.equal(dq.queue_.length, 0);

      done();
    });
  });

});
