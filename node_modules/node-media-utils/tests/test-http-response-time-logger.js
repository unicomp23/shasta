// Copyright Airtime Media, 2022

var chai = require('chai');
var expect = chai.expect;
chai.config.includeStack = true;

const { HttpResponseTimeLogger, ThresholdSpec } = require('../libs/http-response-time-logger');
const { LocalTestServer } = require('./local-test-server');
const { HttpRequest } = require('../libs/http-request');


describe('HttpResponseTimeLogger', function() {
  describe('ThresholdSpec', function() {
    it('should throw if invalid responseTimeMsec is given', function() {
      expect(() => { new ThresholdSpec('warn'); })
        .to.throw('ThresholdSpec.responseTimeMsec needs to be positive number');
    });

    it('should throw if non-positive responseTimeMsec is given', function() {
      expect(() => { new ThresholdSpec(0, 'warn'); })
        .to.throw('ThresholdSpec.responseTimeMsec needs to be positive number');
    });

    it('should throw if overThresholdLogLevelis missing', function() {
      expect(() => { new ThresholdSpec(100); })
        .to.throw('ThresholdSpec.overThresholdLogLevel is missing or invalid');
    });

    it('should throw if invalid overThresholdLogLevel is given', function() {
      expect(() => { new ThresholdSpec(100, 200); })
        .to.throw('ThresholdSpec.overThresholdLogLevel is missing or invalid');
    });
  });

  describe('constructor', function() {
    it('should throw if logLevel is not given', function() {
      expect(() => {
        new HttpResponseTimeLogger();
      }).to.throw('need correct logLevel');
    });

    it('should throw if invalid logLevel type is given', function() {
      expect(() => {
        new HttpResponseTimeLogger(true);
      }).to.throw('need correct logLevel');
    });

    it('should throw if invalid logLevel value is given', function() {
      expect(() => {
        new HttpResponseTimeLogger('never-log');
      }).to.throw('Given log level never-log is invalid');
    });

    it('should throw if invalid logLevel value in thresholdSpec is given', function() {
      expect(() => {
        new HttpResponseTimeLogger('info', new ThresholdSpec(1000, 'dontlog'));
      }).to.throw('Given log level dontlog is invalid');
    });
  });

  describe('automatic log', function() {
    let testee;

    afterEach(function() {
      // HttpRessponseTimeLogger attaches hooks to Node JS http.
      // Thus, here we clean up the |require| cache for next require to load original http
      if (testee) testee.unhook();
      testee = null;
    });

    it('should log response time', async function() {
      const testLogOutput = [];
      const testLogger = {
        debug: (msg) => { testLogOutput.push('debug: ' + msg)},
        info: (msg) => { testLogOutput.push('info: ' + msg)}
      };

      // instantiating LocalTestServer before HttpResponseTimeLogger so that the hook is not set to the test server
      const testServer = new LocalTestServer();
      const respDelayMsec = 50;
      const [ notUsed, testPort ] = await testServer.run({ statusCode: 200, delayMsec: respDelayMsec });

      testee = new HttpResponseTimeLogger('info', testLogger);

      const testClient = new HttpRequest('localhost', testPort, 'http');
      await testClient.send('get', '/path1', {});

      expect(testLogOutput.length).to.equal(2);
      expect(testLogOutput[0]).to.contain('info: REQUEST: GET /path1 id=1');
      expect(testLogOutput[1]).to.contain('info: WRITEHEAD: 200 GET /path1 id=1');
      expect(testLogOutput[1]).to.match(/ [0-9]+msec$/);
      const msecMatch = testLogOutput[1].match(/([0-9]+)msec$/);
      expect(msecMatch[1]).to.be.ok;
      expect(parseInt(msecMatch[1], 10)).to.be.at.least(respDelayMsec);
    });

    it('should log under threshold response time as normal log level', async function() {
      const testLogOutput = [];
      const testLogger = {
        info: (msg) => { testLogOutput.push('info: ' + msg)},
        warn: (msg) => { testLogOutput.push('warn: ' + msg)},
      };

      // instantiating LocalTestServer before HttpResponseTimeLogger so that the hook is not set to the test server
      const testServer = new LocalTestServer();
      const respDelayMsec = 50;
      const [ notUsed, testPort ] = await testServer.run({ statusCode: 200, delayMsec: respDelayMsec });

      testee = new HttpResponseTimeLogger('info', new ThresholdSpec(respDelayMsec * 2, 'warn'), testLogger);

      const testClient = new HttpRequest('localhost', testPort, 'http');
      await testClient.send('get', '/path1', {});

      expect(testLogOutput.length).to.equal(2);
      expect(testLogOutput[0]).to.contain('info: REQUEST: GET /path1 id=1');
      expect(testLogOutput[1]).to.contain('info: WRITEHEAD: 200 GET /path1 id=1');
      expect(testLogOutput[1]).to.match(/ [0-9]+msec$/);
      const msecMatch = testLogOutput[1].match(/([0-9]+)msec$/);
      expect(msecMatch[1]).to.be.ok;
      expect(parseInt(msecMatch[1], 10)).to.be.at.least(respDelayMsec);
    });

    it('should log over threshold response time as higher log level', async function() {
      const testLogOutput = [];
      const testLogger = {
        info: (msg) => { testLogOutput.push('info: ' + msg)},
        warn: (msg) => { testLogOutput.push('warn: ' + msg)},
      };

      // instantiating LocalTestServer before HttpResponseTimeLogger so that the hook is not set to the test server
      const testServer = new LocalTestServer();
      const respDelayMsec = 50;
      const [ notUsed, testPort ] = await testServer.run({ statusCode: 200, delayMsec: respDelayMsec });

      testee = new HttpResponseTimeLogger('info', new ThresholdSpec(respDelayMsec / 2, 'warn'), testLogger);

      const testClient = new HttpRequest('localhost', testPort, 'http');
      await testClient.send('get', '/path1', {});

      expect(testLogOutput.length).to.equal(2);
      expect(testLogOutput[0]).to.contain('info: REQUEST: GET /path1 id=1');
      expect(testLogOutput[1]).to.contain('warn: WRITEHEAD: 200 GET /path1 id=1');
      expect(testLogOutput[1]).to.match(/ [0-9]+msec$/);
      const msecMatch = testLogOutput[1].match(/([0-9]+)msec$/);
      expect(msecMatch[1]).to.be.ok;
      expect(parseInt(msecMatch[1], 10)).to.be.at.least(respDelayMsec);
    });

    it('should ignore the second attempt of hooking by the second constructor', async function() {
      // instantiating LocalTestServer before HttpResponseTimeLogger so that the hook is not set to the test server
      const testServer = new LocalTestServer();
      const [ notUsed, testPort ] = await testServer.run({ statusCode: 200 });

      const testLogOutput = [];
      const testLogger = {
        info: (msg) => { testLogOutput.push('info: ' + msg)},
        warn: (msg) => { testLogOutput.push('warn: ' + msg)},
      };

      testee = new HttpResponseTimeLogger('info', testLogger);

      expect(testLogOutput.length).to.equal(0);

      new HttpResponseTimeLogger('info', testLogger);

      expect(testLogOutput.length).to.equal(1);
      expect(testLogOutput[0]).to.contain('warn: HttpResponseTimeLogger is instantiated again. bailing out');
      testLogOutput.shift();

      // the second hook attempt does not affect the functionality
      const testClient = new HttpRequest('localhost', testPort, 'http');
      await testClient.send('get', '/path1', {});

      expect(testLogOutput.length).to.equal(2);
      expect(testLogOutput[0]).to.contain('info: REQUEST: GET /path1 id=1');
      expect(testLogOutput[1]).to.contain('info: WRITEHEAD: 200 GET /path1 id=1');
    })
  });
});
