/// @copyright Â© 2016 Airtime Media.  All rights reserved.

var chai = require('chai');
var expect = chai.expect;
var assert = chai.assert;
chai.config.includeStack = true;

var os = require('os');
var numCores = os.cpus().length;

var AvgCpuUtil = require('../libs/average-cpu-utilization').AverageCpuUtil;

describe('AverageCpuUtil', function() {
  it('should throw if non-number window size was given', function() {
    try {
      new AvgCpuUtil('aaa', 10);
      expect('should throw').to.be.not.ok;
    } catch (ex) {
      expect(ex.toString()).to.contain('moving average window specification');
    }
  });
  it('should throw if non-number sample frequence was given', function() {
    try {
      new AvgCpuUtil(10, {});
      expect('should throw').to.be.not.ok;
    } catch (ex) {
      expect(ex.toString()).to.contain('sampling frequency');
    }
  });
  it('should throw if one of window is less than frequency', function() {
    try {
      new AvgCpuUtil([10, 4, 20], 5);
      expect('should throw').to.be.not.ok;
    } catch (ex) {
      expect(ex.toString()).to.contain('4 cannot be smaller than sample freq. 5');
    }
  });

  var load = function(duration) {
    var start = Date.now();
    setTimeout(() => {
      var f = 0.0;
      while (Date.now() < start + duration) {
        f += 1.23;
      }
    }, 0);
  };

  describe('measurement', function() {
    var testee;

    afterEach(function() {
      // mocha needs this stop to finish tests
      testee.stop();
    });
  
    it('should measure average cpu utilizations', function(done) {
      this.timeout(2000);
      testee = new AvgCpuUtil([1, 0.5], 0.1);

      // initial value
      var result = testee.getAverages();
      expect(Object.keys(result).length).to.equal(2);
      expect(result[1]).to.equal(0);
      expect(result[0.5]).to.equal(0);

      // get it earlier than window time
      setTimeout(function() {
        var result = testee.getAverages();
        expect(Object.keys(result).length).to.equal(2);
        expect(result[1]).to.within(0.0001, 1.0);
        expect(result[0.5]).to.within(0.0001, 1.0);

        // later than smaller window
        setTimeout(function() {
          var result = testee.getAverages();
          expect(Object.keys(result).length).to.equal(2);
          expect(result[1]).to.within(0.0001, 1.0);
          expect(result[0.5]).to.within(0.0001, 1.0);

          // later than bigger window
          setTimeout(function() {
            var result = testee.getAverages();
            expect(Object.keys(result).length).to.equal(2);
            expect(result[1]).to.within(0.0001, 1.0);
            expect(result[0.5]).to.within(0.0001, 1.0);

            // save for compare
            var lastResult = result;

            // one more test, with no load this time
            setTimeout(function() {
              var result = testee.getAverages();
              expect(Object.keys(result).length).to.equal(2);
              expect(result[1]).to.within(0.0001, 1.0);
              expect(result[0.5]).to.within(0.0001, 1.0);

              // this time, it had no load, so value this time must be lower than before
              expect(result[1]).to.be.below(lastResult[1]);
              expect(result[0.5]).to.be.below(lastResult[0.5]);

              done();
            }, 800);
            // no load this time
          }, 500);
          // a bit of load
          loadTimer = load(450);
        }, 300);
        // a bit of load
        loadTimer = load(250);
      }, 300);
      // a bit of load
      loadTimer = load(250);
    });

    it('should correctly measure even if sample rate does not align with window', function(done) {
      this.timeout(3000);
      testee = new AvgCpuUtil([1.3, 0.7], 0.2);

      // initial value
      var result = testee.getAverages();
      expect(Object.keys(result).length).to.equal(2);
      expect(result[1.3]).to.equal(0);
      expect(result[0.7]).to.equal(0);

      // get it earlier than window time
      setTimeout(function() {
        var result = testee.getAverages();
        expect(Object.keys(result).length).to.equal(2);
        expect(result[1.3]).to.within(0.0001, 1.0);
        expect(result[0.7]).to.within(0.0001, 1.0);

        // later than smaller window
        setTimeout(function() {
          var result = testee.getAverages();
          expect(Object.keys(result).length).to.equal(2);
          expect(result[1.3]).to.within(0.0001, 1.0);
          expect(result[0.7]).to.within(0.0001, 1.0);

          // later than bigger window
          setTimeout(function() {
            var result = testee.getAverages();
            expect(Object.keys(result).length).to.equal(2);
            expect(result[1.3]).to.within(0.0001, 1.0);
            expect(result[0.7]).to.within(0.0001, 1.0);

            // save for compare
            var lastResult = result;

            // one more test, with no load this time
            setTimeout(function() {
              var result = testee.getAverages();
              expect(Object.keys(result).length).to.equal(2);
              expect(result[1.3]).to.within(0.0001, 1.0);
              expect(result[0.7]).to.within(0.0001, 1.0);

              // this time, it had no load, so value this time must be lower than before
              expect(result[1.3]).to.be.below(lastResult[1.3]);
              expect(result[0.7]).to.be.below(lastResult[0.7]);

              // mocha needs this stop to finish tests
              testee.stop();

              done();
            }, 650);
            // no load this time
          }, 600);
          // a bit of load
          loadTimer = load(550);
        }, 450);
        // a bit of load
        loadTimer = load(400);
      }, 450);
      // a bit of load
      loadTimer = load(400);
    });
  });
});
