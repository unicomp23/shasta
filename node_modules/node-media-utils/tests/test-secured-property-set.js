// Copyright Airtime Media, 2022

var chai = require('chai');
var expect = chai.expect;
chai.config.includeStack = true;

const SecuredPropertySet = require('../libs/secured-property-set').SecuredPropertySet;
const FORCE_DEBUG_MODE = SecuredPropertySet.FORCE_DEBUG_MODE;
const FORCE_RELEASE_MODE = SecuredPropertySet.FORCE_RELEASE_MODE;

describe('SecuredPropertySet', function() {
  class XYZ extends SecuredPropertySet {
    constructor(...args) {
      super([ 'aaa', 'bbb' ], ...args);
    }
    // own method
    getHello(who) { return 'hello ' + who; }
    // private method (perhaps)
    set_(name, value) { this[name] = value; }
  }

  it('should show its subclass name', function() {
    const releaseSub = new XYZ(FORCE_RELEASE_MODE);
    expect(releaseSub.className).to.equal('XYZ');

    const debugSub = new XYZ(FORCE_DEBUG_MODE);
    expect(debugSub.className).to.equal('XYZ');
  });

  it('should list its property names', function() {
    const releaseSub = new XYZ(FORCE_RELEASE_MODE);
    expect(releaseSub.propertyNames.length).to.equal(2);
    expect(releaseSub.propertyNames).to.contain('aaa');
    expect(releaseSub.propertyNames).to.contain('bbb');

    const debugSub = new XYZ(FORCE_DEBUG_MODE);
    expect(debugSub.propertyNames.length).to.equal(2);
    expect(debugSub.propertyNames).to.contain('aaa');
    expect(debugSub.propertyNames).to.contain('bbb');
  });

  it('should show its mode', function() {
    const releaseSub = new XYZ(FORCE_RELEASE_MODE);
    expect(releaseSub.inDebugMode).to.be.false;

    const debugSub = new XYZ(FORCE_DEBUG_MODE);
    expect(debugSub.inDebugMode).to.be.true;
  });

  it('should be able to set and get predefined property', function() {
    const verify = (sub) => {
      sub.aaa = {};
      expect(sub.aaa).to.deep.equal({});
      sub.aaa = [];
      expect(sub.aaa).to.deep.equal([]);
      sub.aaa = [ 1, 2, 3 ];
      expect(sub.aaa).to.deep.equal([ 1, 2, 3 ]);

      sub.bbb = undefined;
      expect(sub.bbb).to.equal(undefined);
      sub.bbb = null;
      expect(sub.bbb).to.equal(null);
      sub.bbb = 'BBB';
      expect(sub.bbb).to.equal('BBB');
    };
    const releaseSub = new XYZ(FORCE_RELEASE_MODE);
    verify(releaseSub);
    const debugSub = new XYZ(FORCE_DEBUG_MODE);
    verify(debugSub);
  });

  it('should set initial values', function() {
    const verify = (sub) => {
      expect(sub.has('aaa')).to.be.true;
      expect(sub.aaa).to.equal('AAA');
      expect(sub.has('bbb')).to.be.true;
      expect(sub.bbb).to.equal('BBB');
    };
    const releaseSub = new XYZ({ aaa: 'AAA', bbb: 'BBB' }, FORCE_RELEASE_MODE);
    verify(releaseSub);
    const debugSub = new XYZ({ aaa: 'AAA', bbb: 'BBB' }, FORCE_DEBUG_MODE);
    verify(debugSub);
  });

  it('should reject to initialize with extra property', function() {
    expect(() => { new XYZ({ aaa: 1, bbb: 2, ccc: 3 }, FORCE_DEBUG_MODE); })  // eslint-disable-line no-new
      .to.throw("XYZ has no property 'ccc' to set");
  });

  it('should check its property has set before get', function() {
    const verify = (sub, debugMode) => {
      expect(sub.has('aaa')).to.be.false;
      expect(sub.has('bbb')).to.be.false;
      sub.bbb = 123;
      expect(sub.has('aaa')).to.be.false;
      expect(sub.has('bbb')).to.be.true;
      expect(sub.bbb).to.equal(123);
      sub.bbb = 234;
      expect(sub.bbb).to.equal(234);
      expect(sub.has('aaa')).to.be.false;
      expect(sub.has('bbb')).to.be.true;
      sub.aaa = undefined;  // even setting undefined make its state 'has set' in debug mode (debug mode only).
      expect(sub.has('aaa')).to.equal(debugMode ? true : false);
      expect(sub.aaa).to.equal(undefined);
      expect(sub.has('bbb')).to.be.true;
    };
    const releaseSub = new XYZ(FORCE_RELEASE_MODE);
    verify(releaseSub, false);
    const debugSub = new XYZ(FORCE_DEBUG_MODE);
    verify(debugSub, true);
  });

  it('should show members by toString or string coercing', function() {
    const verify = (sub) => {
      sub.aaa = [ 10, 'eleven' ];
      sub.bbb = { ccc: true, ddd: ()=>{ return 9; } };
      expect(sub.toString()).to.equal("XYZ:{ aaa: [ 10, 'eleven' ], bbb: { ccc: true, ddd: [Function: ddd] } }");
      expect(sub.toString()).to.equal('' + sub);
    };
    const releaseSub = new XYZ(FORCE_RELEASE_MODE);
    verify(releaseSub);
    const debugSub = new XYZ(FORCE_DEBUG_MODE);
    verify(debugSub);
  });

  it('should allow subclass own methods', function() {
    const sub = new XYZ(FORCE_DEBUG_MODE);
    expect(sub.getHello('totoro')).to.equal('hello totoro');
    sub.set_('bbb', 123);
    expect(sub.bbb).to.equal(123);
  });

  class IncorrectUse extends SecuredPropertySet {
    constructor(...args) { super(...args); }
  }

  it('should throw if no predefined property names were not given', function() {
    expect(() => { new IncorrectUse(); }).to.throw('Need propNames');  // eslint-disable-line no-new
    expect(() => { new IncorrectUse({ a: 10, b: 20 }); }).to.throw('Need propNames');  // eslint-disable-line no-new
    expect(() => { new IncorrectUse(true); }).to.throw('Need propNames');  // eslint-disable-line no-new
  });

  it('should throw if tried to get new property in debug mode', function() {
    const sub = new XYZ(FORCE_DEBUG_MODE);
    expect(() => { sub.ccc; }).to.throw("XYZ has no property 'ccc' to get");
  });

  it('should throw if tried to set new property in debug mode', function() {
    const sub = new XYZ(FORCE_DEBUG_MODE);
    expect(() => { sub.ccc = 3; }).to.throw("XYZ has no property 'ccc' to set");
  });

  it('should throw if tried to get unset property in debug mode', function() {
    const sub = new XYZ(FORCE_DEBUG_MODE);
    expect(() => { sub.aaa; }).to.throw("XYZ property 'aaa' has not set");
  });

  class Base {
    constructor() {
      this.aaa = undefined;
      this.bbb = undefined;
    }
  }
  class RegularSub extends Base {}  // key is, properties in its base class

  class Regular {}

  class Secured extends SecuredPropertySet {
    constructor(...args) {
      super([ 'aaa', 'bbb' ], ...args);
    }
  }

  it('should perform reasonablly fast', function() {
    this.timeout(Math.max(this.timeout(), 10000));  // eslint-disable-line no-invalid-this

    const cycles = 500 * 1000;
    const accessor = (obj, i) => {
      obj.aaa = obj.aaa + i + 1;
      obj.bbb = obj.bbb + i + 10;
    };

    // Note: somehow, the measuring order affects the outcomes,
    //       so we measure them multiple times with different ordering
    const secure = new Secured({ aaa: 0, bbb: 0 }, FORCE_DEBUG_MODE);
    const nonSecure = new Secured({ aaa: 0, bbb: 0 }, FORCE_RELEASE_MODE);
    const regular = new Regular();
    const regularSub = new RegularSub();
    const order = [
      regularSub, regular, nonSecure, secure,
      regular, nonSecure, secure, regularSub,
      nonSecure, secure, regularSub, regular,
      secure, regularSub, nonSecure, regular,
      regular, regularSub, nonSecure, secure,
      nonSecure, regular, secure, regularSub
    ];

    const results = { secure: [], nonSecure: [], regular: [], regularSub: [] };
    const setResult = (testee, time) => {
      switch (testee) {
      case secure: results.secure.push(time); break;
      case nonSecure: results.nonSecure.push(time); break;
      case regular: results.regular.push(time); break;
      case regularSub: results.regularSub.push(time); break;
      default: throw new Error('Unknown testee ' + testee.constructor.name);
      }
    };

    for (const testee of order) {
      testee.aaa = 0; testee.bbb = 0;
      let started = Date.now();
      for (let i = 0; i < cycles; ++i) {
        accessor(testee, i);
      }
      let ended = Date.now();
      setResult(testee, ended - started);
    }

    console.log(JSON.stringify(results));

    const olympicScoring = (samples) => {
      samples = samples.sort();
      if (4 < samples.length) {
        samples.shift(); samples.pop();  // drop lowest and highest score
      }
      return samples.reduce((e1, e2) => e1 + e2) / samples.length;
    };
    const secureScore = olympicScoring(results.secure);
    const nonSecureScore = olympicScoring(results.nonSecure);
    const regularScore = olympicScoring(results.regular);
    const regularSubScore = olympicScoring(results.regularSub);

    expect(secureScore).to.be.at.most(0.001 * cycles);  // at most 1 micro sec per get&set
    expect(nonSecureScore).to.be.at.most(1.1 * regularSubScore);  // it varies but should not be too big
  });
});
