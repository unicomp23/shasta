/**
 * @file Contains unit tests for the auth-validator module
 * 
 * @copyright Copyright Â© 2017 Airtime Media.  All rights reserved.
 */

var assert = require('assert');
var v = require('../libs/auth-validator').auth;

describe('auth-validator', function() {
  describe('garbage inputs', function() {
    it('should fail on garbage input with a single secret', function(done) {
      v.validate('adfsasdfsdafsd', ['secret'], function(err, decoded) {
        assert(err);
        done();
      });
    });

    it('should fail on empty input with a single secret', function(done) {
      v.validate('', ['secret'], function(err, decoded) {
        assert(err);
        done();
      });
    });

    it('should fail on garbage input with multiple secrets', function(done) {
      v.validate('adfasdfasdfadfs', ['secret1', 'secret2', 'secret3'], function(err, decoded) {
        assert(err);
        done();
      });
    });

    it('should fail on empty input with multiple secrets', function(done) {
      v.validate('', ['secret1', 'secret2', 'secret3'], function(err, decoded) {
        assert(err);
        done();
      });
    });

    it('should fail with no secrets', function(done) {
      v.validate('adfasdfasdfadfs', [], function(err, decoded) {
        assert(err);
        done();
      });
    });
  });

  describe('valid tokens', function() {
    /* note that the success cases use a token that expires in 2027 */
    it('should succeed with a valid token and a single secret', function(done) {
      var token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImV4cCI6MTgwMTUyNjQwMH0.O2YnKvjffcMq6Kar0uoTw8Kox7nRp7GaCgv6SXgaGeA';
      v.validate(token, ['secret'], function(err, decoded) {
        if (err) {
          done(err);
        } else {
          assert(decoded.sub === '1234567890');
          assert(decoded.name === 'John Doe');
          done();
        }
      });
    });

    it('should succeed with a valid token when the first secret matches', function(done) {
      var token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImV4cCI6MTgwMTUyNjQwMH0.O2YnKvjffcMq6Kar0uoTw8Kox7nRp7GaCgv6SXgaGeA';
      v.validate(token, ['secret'], function(err, decoded) {
        if (err) {
          done(err);
        } else {
          assert(decoded.sub === '1234567890');
          assert(decoded.name === 'John Doe');
          done();
        }
      });
    });

    it('should succeed with a valid token when the second secret matches', function(done) {
      var token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImV4cCI6MTgwMTUyNjQwMH0.O2YnKvjffcMq6Kar0uoTw8Kox7nRp7GaCgv6SXgaGeA';
      v.validate(token, ['secret0', 'secret'], function(err, decoded) {
        if (err) {
          done(err);
        } else {
          assert(decoded.sub === '1234567890');
          assert(decoded.name === 'John Doe');
          done();
        }
      });
    });

    it('should succeed with a valid token when the third secret matches', function(done) {
      var token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImV4cCI6MTgwMTUyNjQwMH0.O2YnKvjffcMq6Kar0uoTw8Kox7nRp7GaCgv6SXgaGeA';
      v.validate(token, ['secret0', 'secret1', 'secret'], function(err, decoded) {
        if (err) {
          done(err);
        } else {
          assert(decoded.sub === '1234567890');
          assert(decoded.name === 'John Doe');
          done();
        }
      });
    });

    it('should fail with a valid token when none of several secrets matches', function(done) {
      var token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImV4cCI6MTgwMTUyNjQwMH0.O2YnKvjffcMq6Kar0uoTw8Kox7nRp7GaCgv6SXgaGeA';
      v.validate(token, ['secret0', 'secret1', 'secret2'], function(err, decoded) {
        assert(err);
        assert(err.name === "BadSignature");
        done();
      });
    });

    it('should fail for an expired token', function(done) {
      var token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImV4cCI6MTQ4NTk5Nzk5Mn0.OFsmkwFO3brGFZVTIJOPgEADZI_-nlyHs16_JXXYSso';
      v.validate(token, ['secret'], function(err, decoded) {
        assert(err);
        assert(err.name === "TokenExpiredError");
        done();
      });      
    });

  });
});