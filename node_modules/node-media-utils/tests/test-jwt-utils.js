// Copyright Airtime Media, 2022

var chai = require('chai');
var expect = chai.expect;
chai.config.includeStack = true;

const JwtUtils = require('../libs/jwt-utils.js');
const { signJwtHS256, parseJwt, verifyJwtHS256, signJwtRS256, verifyJwtRS256, generateKey, parseJwtHeader } = JwtUtils;

describe('JWT utils', function() {
  let keyObj;
  before(async function() {
    keyObj = await generateKey();
  });

  it('should sign and verify HS256 JWT', function() {
    const obj = { aaa: 'AAA', bbb: 1234 };
    const secret = 'never tell anybody';
    const jwt = signJwtHS256(obj, secret);

    const now = parseInt(Date.now() / 1000, 10);
    const peek = parseJwt(jwt);
    expect(peek.aaa).to.equal('AAA');
    expect(peek.bbb).to.equal(1234);
    expect(peek.iat).to.be.at.least(now);

    try {
      const verified = verifyJwtHS256(jwt, secret);
      expect(verified.aaa).to.equal('AAA');
      expect(verified.bbb).to.equal(1234);
      const header = parseJwtHeader(jwt);
      expect(Object.keys(header).length).to.equal(2);
      expect(header.typ).equal('JWT');
      expect(header.alg).to.equal('HS256');
    } catch (err) {
      expect(err.message).to.be.empty;
    }
  });

  it('should sign and verify HS256 JWT with additional header items', function() {
    const obj = { aaa: 'AAA', bbb: 1234 };
    const secret = 'never tell anybody';
    const header = { head1: 10, head2: 'BBB' };
    const jwt = signJwtHS256(obj, secret, header);

    const now = parseInt(Date.now() / 1000, 10);
    const peek = parseJwt(jwt);
    expect(peek.aaa).to.equal('AAA');
    expect(peek.bbb).to.equal(1234);
    expect(peek.iat).to.be.at.least(now);

    try {
      const verified = verifyJwtHS256(jwt, secret);
      expect(verified.aaa).to.equal('AAA');
      expect(verified.bbb).to.equal(1234);
      const header = parseJwtHeader(jwt);
      expect(Object.keys(header).length).to.equal(4);
      expect(header.typ).equal('JWT');
      expect(header.alg).to.equal('HS256');
      expect(header.head1).to.equal(10);
      expect(header.head2).to.equal('BBB');
    } catch (err) {
      expect(err.message).to.be.empty;
    }
  });

  it('should sign and verify HS256 JWT with empty additional header items', function() {
    const obj = { aaa: 'AAA', bbb: 1234 };
    const secret = 'never tell anybody';
    const header = {};
    const jwt = signJwtHS256(obj, secret, header);

    const now = parseInt(Date.now() / 1000, 10);
    const peek = parseJwt(jwt);
    expect(peek.aaa).to.equal('AAA');
    expect(peek.bbb).to.equal(1234);
    expect(peek.iat).to.be.at.least(now);

    try {
      const verified = verifyJwtHS256(jwt, secret);
      expect(verified.aaa).to.equal('AAA');
      expect(verified.bbb).to.equal(1234);
      const header = parseJwtHeader(jwt);
      expect(Object.keys(header).length).to.equal(2);
      expect(header.typ).equal('JWT');
      expect(header.alg).to.equal('HS256');
    } catch (err) {
      expect(err.message).to.be.empty;
    }
  });

  it('should sign and verify HS256 JWT, no iat', function() {
    const obj = { aaa: 'AAA', bbb: 1234 };
    const secret = 'never tell anybody';
    const noIat = true;
    const jwt = signJwtHS256(obj, secret, noIat);

    const peek = parseJwt(jwt);
    expect(peek.aaa).to.equal('AAA');
    expect(peek.bbb).to.equal(1234);
    expect(peek.iat).to.be.undefined;

    try {
      const verified = verifyJwtHS256(jwt, secret, true);
      expect(verified.aaa).to.equal('AAA');
      expect(verified.bbb).to.equal(1234);
    } catch (err) {
      expect(err.message).to.be.empty;
    }
  });

  it('should sign and verify HS256 JWT with additional header items and no iat', function() {
    const obj = { aaa: 'AAA', bbb: 1234 };
    const secret = 'never tell anybody';
    const header = { head1: 10, head2: 'BBB' };
    const noIat = true;
    const jwt = signJwtHS256(obj, secret, header, noIat);

    const peek = parseJwt(jwt);
    expect(peek.aaa).to.equal('AAA');
    expect(peek.bbb).to.equal(1234);
    expect(peek.iat).to.be.undefined;

    try {
      const verified = verifyJwtHS256(jwt, secret);
      expect(verified.aaa).to.equal('AAA');
      expect(verified.bbb).to.equal(1234);
      const header = parseJwtHeader(jwt);
      expect(header.head1).to.equal(10);
      expect(header.head2).to.equal('BBB');
    } catch (err) {
      expect(err.message).to.be.empty;
    }
  });

  it('should sign and verify expired HS256 JWT if ignoring expiration', function() {
    const obj = { aaa: 'AAA', bbb: 1234, exp: 100 };
    const secret = 'never tell anybody';
    const jwt = signJwtHS256(obj, secret);

    const peek = parseJwt(jwt);
    expect(peek.aaa).to.equal('AAA');
    expect(peek.bbb).to.equal(1234);

    try {
      const ignoreExpiration = true;
      const verified = verifyJwtHS256(jwt, secret, ignoreExpiration);
      expect(verified.aaa).to.equal('AAA');
      expect(verified.bbb).to.equal(1234);
    } catch (err) {
      expect(err.message).to.be.empty;
    }
  });

  it('should throw if given JWT is not JWT', function() {
    const jwt = 'this.is.not.a.jwt';

    const peek = parseJwt(jwt);
    expect(peek).to.equal(null);

    const secret = 'never tell anybody';
    expect(() => {
      verifyJwtHS256(jwt, secret);
    }).to.throw();
  });

  it('should throw if verifying HS256 JWT with different secret', function() {
    const obj = { aaa: 'AAA', bbb: 1234 };
    const secret = 'never tell anybody';
    const jwt = signJwtHS256(obj, secret);

    expect(() => {
      verifyJwtHS256(jwt, secret + '-different');
    }).to.throw();
  });

  it('should sign and validate RS256 JWT', async function() {
    const obj = { aaa: 'AAA', bbb: 1234 };
    const now = parseInt(Date.now() / 1000, 10);
    const jwt = signJwtRS256(obj, keyObj.private);

    try {
      const verified = verifyJwtRS256(jwt, keyObj.public);
      expect(verified.aaa).to.equal('AAA');
      expect(verified.bbb).to.equal(1234);
      expect(verified.iat).to.be.at.least(now);
      const header = parseJwtHeader(jwt);
      expect(Object.keys(header).length).to.equal(2);
      expect(header.typ).equal('JWT');
      expect(header.alg).to.equal('RS256');
    } catch (err) {
      expect(err.message).to.be.empty;
    }
  });

  it('should sign and validate RS256 JWT with additional header items', async function() {
    const obj = { aaa: 'AAA', bbb: 1234 };
    const header = { head1: 10, head2: 'BBB' };
    const now = parseInt(Date.now() / 1000, 10);
    const jwt = signJwtRS256(obj, keyObj.private, header);

    try {
      const verified = verifyJwtRS256(jwt, keyObj.public);
      expect(verified.aaa).to.equal('AAA');
      expect(verified.bbb).to.equal(1234);
      expect(verified.iat).to.be.at.least(now);
      const header = parseJwtHeader(jwt);
      expect(Object.keys(header).length).to.equal(4);
      expect(header.typ).equal('JWT');
      expect(header.alg).to.equal('RS256');
      expect(header.head1).to.equal(10);
      expect(header.head2).to.equal('BBB');
    } catch (err) {
      expect(err.message).to.be.empty;
    }
  });

  it('should sign and validate RS256 JWT with empty additional header items', async function() {
    const obj = { aaa: 'AAA', bbb: 1234 };
    const header = {};
    const now = parseInt(Date.now() / 1000, 10);
    const jwt = signJwtRS256(obj, keyObj.private, header);

    try {
      const verified = verifyJwtRS256(jwt, keyObj.public);
      expect(verified.aaa).to.equal('AAA');
      expect(verified.bbb).to.equal(1234);
      expect(verified.iat).to.be.at.least(now);
      const header = parseJwtHeader(jwt);
      expect(Object.keys(header).length).to.equal(2);
      expect(header.typ).equal('JWT');
      expect(header.alg).to.equal('RS256');
    } catch (err) {
      expect(err.message).to.be.empty;
    }
  });

  it('should sign and validate RS256 JWT, no iat', async function() {
    const obj = { aaa: 'AAA', bbb: 1234 };
    const noIat = true;
    const jwt = signJwtRS256(obj, keyObj.private, noIat);

    try {
      const verified = verifyJwtRS256(jwt, keyObj.public);
      expect(verified.aaa).to.equal('AAA');
      expect(verified.bbb).to.equal(1234);
      expect(verified.iat).to.be.undefined;
    } catch (err) {
      expect(err.message).to.be.empty;
    }
  });

  it('should throw if signing JWT is not JWT', async function() {
    const jwt = 'not.right.jwt';

    const peek = parseJwt(jwt);
    expect(peek).to.equal(null);

    expect(() => {
      verifyJwtRS256(jwt, keyObj.public);
    }).to.throw();
  });

  it('should throw if verifying RS256 JWT with wrong RS256 key', async function() {
    const obj = { aaa: 'AAA', bbb: 1234 };
    const jwt = signJwtRS256(obj, keyObj.private);

    const differentKeyObj = await generateKey();
    expect(() => {
      verifyJwtRS256(jwt, differentKeyObj.public);
    }).to.throw();
  });

  it('should throw if verifying RS256 JWT with HS256 secret', async function() {
    const obj = { aaa: 'AAA', bbb: 1234 };
    const jwt = signJwtRS256(obj, keyObj.private);

    const secret = 'this is HS256 secret';
    expect(() => {
      verifyJwtHS256(jwt, secret);
    }).to.throw();
  });

  it('should throw if verifying HS256 JWT with RS256 public key', async function() {
    const obj = { aaa: 'AAA', bbb: 1234 };
    const secret = 'never tell anybody';
    const jwt = signJwtHS256(obj, secret);

    expect(() => {
      verifyJwtRS256(jwt, keyObj.public);
    }).to.throw();
  });

  it('should throw if malformed JWT is given to parseJwtHeader', function() {
    const badJwt = 'zzz_-^%#.aaaa.bbbb';  // header contains non-base64 characters
    expect(() => parseJwtHeader(badJwt)).to.throw(
      'Unexpected token √è in JSON at position 0 while decoding JWT header of ' + badJwt);
  });
});
